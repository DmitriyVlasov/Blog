[{"authors":["me"],"categories":null,"content":" \u0026ldquo;Ваше время ограничено, поэтому не тратьте его, живя чужой жизнью. Не попадайтесь в ловушку догмы, которая заставляет жить мыслями других людей. Не позволяйте шуму чужих мнений перебить ваш внутренний голос. И самое главное — имейте храбрость следовать вашему сердцу и интуиции.\u0026rdquo;, Стив Джобс\n ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"ru","lastmod":-62135596800,"objectID":"f8f9a3384bdb64736380a1b633f3701b","permalink":"https://DmitriyVlasov.ru/ru/authors/me/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/ru/authors/me/","section":"authors","summary":" \u0026ldquo;Ваше время ограничено, поэтому не тратьте его, живя чужой жизнью. Не попадайтесь в ловушку догмы, которая заставляет жить мыслями других людей. Не позволяйте шуму чужих мнений перебить ваш внутренний голос. И самое главное — имейте храбрость следовать вашему сердцу и интуиции.\u0026rdquo;, Стив Джобс\n ","tags":null,"title":"Дмитрий Власов","type":"authors"},{"authors":null,"categories":null,"content":" Flexibility This feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete tutorials To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]] name = \u0026quot;Courses\u0026quot; url = \u0026quot;courses/\u0026quot; weight = 50  Or, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]] name = \u0026quot;Docs\u0026quot; url = \u0026quot;docs/\u0026quot; weight = 50  Update the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"ru","lastmod":1536451200,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://DmitriyVlasov.ru/ru/courses/example/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/ru/courses/example/","section":"courses","summary":"Learn how to use Academic's docs layout for publishing online courses, software documentation, and tutorials.","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":" In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1557010800,"objectID":"74533bae41439377bd30f645c4677a27","permalink":"https://DmitriyVlasov.ru/ru/courses/example/example1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/ru/courses/example/example1/","section":"courses","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim.","tags":null,"title":"Example Page 1","type":"docs"},{"authors":null,"categories":null,"content":"FParsec состоит из двух библиотек: FParsec.dll и FParsecCS.dll. Для использования FParsec в вашем проекте, вы можете или установить из nuget (см. подробнее варианты установки nuget-пакетовen), или собрать два DLL файла FParsec из исходного кода. Самый простой способ собрать FParsec из исходного кода это использовать файлы решений Visual Studio в каталогах =Build/VS исходного кода пакета, например, в каталоге Build/VS11 для Visual Studio 2012. Любой проект, который использует библиотеку FParsec должен ссылаться на оба файла DLL. Смотри подробнее в руководстве пользователя главу Загрузка и установкаen.\nВсе типы и модули библиотеки FParsec объявлены в пространстве имен FParsec. Это пространство имен содержит несколько базовых классов (например, CharStream и Reply) и четыре F# модуля, а именно: - Primitives, содержащий основные определения типов и комбинаторов синтаксического анализа, - CharParsers, содержащий синтаксические анализаторы для символов, строк, чисел и функций для применения синтаксических анализаторов для входных потоков, - Error, содержащий типы и вспомогательные функции для создания, обработки, форматирования сообщений об ошибках синтаксического анализа, - StaticMapping, содержащий функции для создания оптимизированных функций отображения между ключами и значениями.\nВо всех примерах в этом учебнике предполагается, что вы открыли пространство имен FParsec:\nopen FParsec  При открытии пространства имен FParsec также автоматически открываются модули Primitives, CharParsers и Error.\n Все примеры кода в этом учебнике содержатся в проекте Samples/Tutorial. Читая учебник может быть весьма полезным держать этот проект открытым в окне редактора Visual Studio. Например, вы можете навести курсор мыши на идентификатор, чтобы получить всплывающее окно Intellisense с выведенным типом. А если вам интересно, как функция библиотеки реализована, вы можете открыть контекстное меню и выбрать Перейти к определению (F12).   ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"af5005ed22cc8e1143a3eaab15062a03","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/01-preliminaries/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/01-preliminaries/","section":"publication","summary":"FParsec состоит из двух библиотек: FParsec.dll и FParsecCS.dll. Для использования FParsec в вашем проекте, вы можете или установить из nuget (см. подробнее варианты установки nuget-пакетовen), или собрать два DLL файла FParsec из исходного кода. Самый простой способ собрать FParsec из исходного кода это использовать файлы решений Visual Studio в каталогах =Build/VS исходного кода пакета, например, в каталоге Build/VS11 для Visual Studio 2012. Любой проект, который использует библиотеку FParsec должен ссылаться на оба файла DLL.","tags":null,"title":"Глава 1. Вступление","type":"publication"},{"authors":null,"categories":null,"content":" Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 4 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1557010800,"objectID":"1c2b5a11257c768c90d5050637d77d6a","permalink":"https://DmitriyVlasov.ru/ru/courses/example/example2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/ru/courses/example/example2/","section":"courses","summary":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus.","tags":null,"title":"Example Page 2","type":"docs"},{"authors":null,"categories":null,"content":"Синтаксический разбор входного потока включает два этапа: 1. построение синтаксического анализатора и 1. применение анализатора к входному потоку.\nДавайте начнем с простого примера: синтаксический разбор строки представляющей собой отдельное число с плавающей точкой. В этом случае первый шаг \u0026mdash; построение синтаксического анализатора, просто, поскольку модуль CharParsers уже поставляется со встроенным анализатором числа с плавающей точкой:\nval pfloat: Parser\u0026lt;float,'u\u0026gt;  Универсальный тип Parser\u0026lt;'Result,'UserState\u0026gt; является типом всех синтаксических анализаторов в библиотеке FParsec. Если вы перейдете по следующей гиперссылке, вы увидите, что Parser является синонимом для функционального типа. Однако, на данный момент мы не должны вдаваться в подробности типа Parser. Достаточно отметить, что первый аргумент типа представляет тип результата синтаксического анализа. Итак, в рассматриваемом случае тип функции pfloat говорит нам, что, если синтаксический анализ успешно завершен, функция возвращает число с плавающей точкой типа float. Мы не будем использовать пользовательское состояние синтаксического анализатора (UserState) в этом уроке, так что, на данный момент, вы можете просто игнорировать второй аргумент типа.\nЧтобы применить синтаксический анализатор pfloat к строке, мы можем использовать функцию run из модуля CharParsers:\nval run: Parser\u0026lt;'Result, unit\u0026gt; -\u0026gt; string -\u0026gt; ParserResult\u0026lt;'Result,unit\u0026gt;  Функция run, простейшая из ряда функций модуля CharParsers, используется для запуска синтаксических анализаторов по входным данным. Другие функции позволяют вам, например, запускать синтаксические анализаторы по содержимому файла или потоку ввода-вывода (System.IO.Stream).\nФункция run применяет синтаксический анализатор, переданный в качестве первого аргумента к строке переданной в качестве второго аргумента и возвращает возвращенное синтаксическим анализатором значение в виде ParserResult. Тип ParserResult является типом размеченного объединения с двумя вариантами: Success и Failure. В случае, если синтаксический анализатор успешно выполнен, ParserResult содержит результирующее значение, в противном случае он содержит сообщение об ошибке.\nДля упрощения тестирования мы напишем маленькую вспомогательную функцию, которая выводит на печать значение результата или сообщение об ошибке:\nlet test p str = match run p str with | Success(result, _, _) -\u0026gt; printfn \u0026quot;Success: %A\u0026quot; result | Failure(errorMsg, _, _) -\u0026gt; printfn \u0026quot;Failure: %s\u0026quot; errorMsg  Используя вспомогательную функцию, мы можем протестировать pfloat выполнив:\ntest pfloat \u0026quot;1.25\u0026quot;  что дает в результате:\nSuccess: 1.25  Тестирование pfloat с числовым литералом, который имеет недопустимый знак экспоненты\ntest pfloat \u0026quot;1.25E 3\u0026quot;  дает сообщение об ошибке\nFailure: Error in Ln: 1 Col: 6 1.25E 3 ^ Expecting: decimal digit  ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"7773072a83792c595db0c3e31ae5d924","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/02-parsing-a-single-float/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/02-parsing-a-single-float/","section":"publication","summary":"Синтаксический разбор входного потока включает два этапа: 1. построение синтаксического анализатора и 1. применение анализатора к входному потоку.\nДавайте начнем с простого примера: синтаксический разбор строки представляющей собой отдельное число с плавающей точкой. В этом случае первый шаг \u0026mdash; построение синтаксического анализатора, просто, поскольку модуль CharParsers уже поставляется со встроенным анализатором числа с плавающей точкой:\nval pfloat: Parser\u0026lt;float,'u\u0026gt;  Универсальный тип Parser\u0026lt;'Result,'UserState\u0026gt; является типом всех синтаксических анализаторов в библиотеке FParsec. Если вы перейдете по следующей гиперссылке, вы увидите, что Parser является синонимом для функционального типа.","tags":null,"title":"Глава 2. Синтаксический анализатор числа с плавающей точкой","type":"publication"},{"authors":null,"categories":null,"content":"Реализация синтаксических анализаторов с использованием библиотеки FParsec обычно означает, что высокоуровневые синтаксические анализаторы получены как комбинация низкоуровневых анализаторов. Вы начинаете с анализатора примитивов, предоставляемых библиотекой, а затем последовательно объединяете их в анализаторы более высокого уровня, пока вы, наконец, не имеете один синтаксический анализатор для полной обработки входных данных.\nВ следующих главах мы продемонстрируем этот подход, обсуждая различные варианты примеров синтаксических анализаторов, которые построены друг из друга. В этой главе мы начнем с очень простого анализатора для числа с плавающей точкой в скобках:\nlet str s = pstring s let floatBetweenBrackets = str \u0026quot;[\u0026quot; \u0026gt;\u0026gt;. pfloat .\u0026gt;\u0026gt; str \u0026quot;]\u0026quot;   Если вы пытаетесь скомпилировать этот или другой фрагмент кода, и вы получаете ошибку компилятора F# \u0026ldquo;value restriction\u0026rdquo;, пожалуйста посмотрите главу 10 Ограничение значений F#   Определение str и floatBetweenBrackets включает в себя три библиотечные функции, которые мы ранее не рассматривали: pstring, \u0026gt;\u0026gt;. и \u0026gt;\u0026gt;..\nФункция\nval pstring: string -\u0026gt; Parser\u0026lt;string,'u\u0026gt;  принимает строку в качестве аргумента и возвращает синтаксический анализатор для этой строки. Когда анализатор применяется к входному потоку он проверяет соответствуют ли символы во входном потоке строке, заданной в аргументе. Если символы полностью совпадают со строкой, анализатор поглощает их, то есть пропускает и идет дальше. В противном случае он не исполнится и не поглотит входные данные. Когда анализатор успешно обрабатывает, он также возвращает данную строку в качестве результата анализатора, но, поскольку строка константа, вы будете редко использовать этот результат.\nФункция pstring не называется string, потому что иначе она скроет встроенную в F# функцию string. Как правило, имена синтаксических анализаторов в FParsec, которые конфликтуют со встроенными именами функций в F#, имеют префикс \u0026mdash; символ р. Функция pfloat еще один пример этого соглашения об именовании.\nДля экономии нескольких нажатий клавиш, мы сокращаем pstring как str. Так, например, str \u0026quot;[\u0026quot; это синтаксический анализатор, который пропускает символ '['.\nБинарные операторы \u0026gt;\u0026gt;. и .\u0026gt;\u0026gt; имеет следующие типы:\nval (\u0026gt;\u0026gt;.): Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'b,'u\u0026gt; -\u0026gt; Parser\u0026lt;'b,'u\u0026gt; val (.\u0026gt;\u0026gt;): Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'b,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a,'u\u0026gt;  Как вы можете видеть из этих сигнатур, оба оператора являются комбинаторами синтаксических анализаторов, которые строят новый анализатор из двух аргументов \u0026mdash; синтаксических анализаторов. Синтаксический анализатор p1 \u0026gt;\u0026gt;. p2 разбирает p1 и p2 последовательно и возвращает результат p2. Синтаксический анализатор p1 .\u0026gt;\u0026gt; p2 также разбирает p1 и p2 последовательно, но возвращает результат p1 вместо p2. В каждом случае точка указывает на сторону синтаксического анализатора, результат которого возвращается. Объединив оба оператора в p1 \u0026gt;\u0026gt;. р2 .\u0026gt;\u0026gt; p3 мы получим синтаксический анализатор, который разбирает p1, p2 и p3 последовательно и возвращает результат p2.\n Касательно несколько неточной формулировки \u0026ldquo;разбирает p1 и p2 последовательно\u0026rdquo; мы на самом деле имели в виду: синтаксический анализатор p1 применяется к входным данным, и если p1 успешно исполнен, то p2 применяется к остальной части входных данных. В случае если любой из двух элементов синтаксического анализатора не исполнился, совокупный синтаксический анализатор сразу передает сообщение об ошибке.\nВ документации библиотеки FParsec мы часто используем такие выражения, как \u0026ldquo;синтаксический анализ p\u0026rdquo; или \u0026ldquo;синтаксический анализ вхождения p\u0026rdquo;. Вместо этого технически более точным \u0026ldquo;применяется синтаксический анализатор p к остатку входных данных и если p успешно исполнен\u0026hellip;\u0026ldquo;, надеясь, что точное значение очевидно из контекста.\n  Следующие тесты показывают, что floatBetweenBrackets разбирает правильные входные данные, как и ожидалось, и дает информативные сообщения об ошибках, когда он сталкивается с неправильными входными данными:\n\u0026gt; test floatBetweenBrackets \u0026quot;[1.0]\u0026quot;;; Success: 1.0 \u0026gt; test floatBetweenBrackets \u0026quot;[]\u0026quot;;; Failure: Error in Ln: 1 Col: 2 [] ^ Expecting: floating-point number \u0026gt; test floatBetweenBrackets \u0026quot;[1.0\u0026quot;;; Failure: Error in Ln: 1 Col: 5 [1.0 ^ Note: The error occurred at the end of the input stream. Expecting: ']'    Обратите внимание, что все инфиксные F# операторы, которые начинаются с \u0026lt; или \u0026gt; (ведущие символы . игнорируются) являются левоассоциативными. Следовательно, p1 \u0026gt;\u0026gt;. р2 .\u0026gt;\u0026gt; p3 эквивалентно (p1 \u0026gt;\u0026gt;. p2) .\u0026gt;\u0026gt; p3. Тем не менее, в этом случае ассоциативность не имеет никакого влияния на совокупное поведение синтаксического анализатора.    ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"a5f2a68ed68f9bbc3c24d212de10bbf2","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/03-parsing-a-float-between-brackets/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/03-parsing-a-float-between-brackets/","section":"publication","summary":"Реализация синтаксических анализаторов с использованием библиотеки FParsec обычно означает, что высокоуровневые синтаксические анализаторы получены как комбинация низкоуровневых анализаторов. Вы начинаете с анализатора примитивов, предоставляемых библиотекой, а затем последовательно объединяете их в анализаторы более высокого уровня, пока вы, наконец, не имеете один синтаксический анализатор для полной обработки входных данных.\nВ следующих главах мы продемонстрируем этот подход, обсуждая различные варианты примеров синтаксических анализаторов, которые построены друг из друга. В этой главе мы начнем с очень простого анализатора для числа с плавающей точкой в скобках:","tags":null,"title":"Глава 3. Синтаксический анализатор числа с плавающей точкой в скобках","type":"publication"},{"authors":null,"categories":null,"content":"Одной из самых больших сильных сторон FParsec является легкость, с которой вы можете определить свои собственные абстрактные синтаксические анализаторы.\nВозьмем, к примеру floatBetweenBrackets из предыдущей главы. Если вы намерены также разобрать другие элементы между строк, вы можете определить свой собственный специализированный комбинатор для этой цели:\nlet betweenStrings s1 s2 p = str s1 \u0026gt;\u0026gt;. p .\u0026gt;\u0026gt; str s2  Затем можно определить floatInBrackets и другие синтаксические анализаторы с помощью этого комбинатора:\nlet floatBetweenBrackets = pfloat |\u0026gt; betweenStrings \u0026quot;[\u0026quot; \u0026quot;]\u0026quot; let floatBetweenDoubleBrackets = pfloat |\u0026gt; betweenStrings \u0026quot;[[\u0026quot; \u0026quot;]]\u0026quot;   В случае, если вы новичок в F#: pfloat |\u0026gt; betweenStrings \u0026quot;[\u0026quot; \u0026quot;]\u0026quot; это просто еще один способ, чтобы написать betweenStrings \u0026quot;[\u0026quot; \u0026quot;]\u0026quot; pfloat.   В тот момент, как вы заметите, что вам часто нужно применять синтаксический анализатор между двумя другими, вы можете пойти дальше, представив функцию betweenStrings следующим образом:\nlet between pBegin pEnd p = pBegin \u0026gt;\u0026gt;. p .\u0026gt;\u0026gt; pEnd let betweenStrings s1 s2 p = p |\u0026gt; between (str s1) (str s2)  На самом деле, вам не нужно определять between, потому что это уже встроенный комбинатор FParsec.\nВсе это, конечно, простые примеры. Но поскольку FParsec это лишь библиотека F#, а не какой-то внешний инструмент для генерации синтаксического анализатора, нет никаких ограничений на абстракции, которые можно определять. Вы можете написать функции, которые принимают любые, необходимые вам, входные данные, делают на входных данных вычисления произвольной сложности, а затем возвращают синтаксический анализатор специального назначения или комбинатор синтаксических анализаторов.\nНапример, вы можете написать функцию, которая принимает шаблон регулярного выражения в качестве входных данных и возвращает Parser для разбора входных данных, соответствующих этому шаблону. Эта функция может использовать другой синтаксический анализатор для разбора шаблона регулярного выражения в абстрактное синтаксическое дерево, а затем компилировать абстрактное синтаксическое дерево в функцию синтаксического анализатора специального назначения. Кроме того, она может построить регулярное выражение .NET из шаблона, а затем вернуть функцию синтаксического анализатора, которая использует интерфейс прикладного программирования модуля CharStream библиотеки FParsec для непосредственного применения регулярного выражения к входному потоку (который является на самом деле встроенным синтаксический анализатором regex модуля CharStream).\nДругой пример \u0026mdash; расширяемые приложения синтаксического анализатора. При хранении функций синтаксического анализатора в словарях или других структурах данных и определении соответствующего расширенного протокола, вы можете разрешить подключаемым модулям динамически регистрировать новые синтаксические анализаторы или изменять существующие.\nВозможности действительно бесконечны. Но прежде, чем вы сможете в полной мере использовать эти возможности, вам сначала необходимо ознакомиться с основами FParsec.\n","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"68634df0932a257905f832abc62cfcd0","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/04-abstracting-parsers/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/04-abstracting-parsers/","section":"publication","summary":"Одной из самых больших сильных сторон FParsec является легкость, с которой вы можете определить свои собственные абстрактные синтаксические анализаторы.\nВозьмем, к примеру floatBetweenBrackets из предыдущей главы. Если вы намерены также разобрать другие элементы между строк, вы можете определить свой собственный специализированный комбинатор для этой цели:\nlet betweenStrings s1 s2 p = str s1 \u0026gt;\u0026gt;. p .\u0026gt;\u0026gt; str s2  Затем можно определить floatInBrackets и другие синтаксические анализаторы с помощью этого комбинатора:","tags":null,"title":"Глава 4. Абстрактные синтаксические анализаторы","type":"publication"},{"authors":null,"categories":null,"content":"Мы уже течение трех глав обсуждаем как делать синтаксический разбор одного числа с плавающей запятой, поэтому в этот раз мы попытаемся нечто более амбициозное: синтаксический разбор списка чисел с плавающей точкой.\nПредположим сначала, что нам нужно, чтобы делать синтаксический разбор последовательности чисел с плавающей точкой в скобках, т.е. текст в формате расширенной формы Бэкуса-Наура (далее РБНФ): (\u0026quot;[\u0026quot; float \u0026quot;]\u0026quot;)*. Допустимые входные строки в этом формате, например: \u0026quot;\u0026quot;, \u0026quot;[1.0]\u0026quot;, \u0026quot;[2][3][4]\u0026quot;.\nПоскольку у нас уже есть синтаксический анализатор для числа с плавающей точкой в скобках, нам нужен только способ неоднократно применять этот синтаксический анализатор для разбора последовательности. Именно это этого предназначен комбинатор many:\nval many: Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a list,'u\u0026gt;  Синтаксический анализатор many p повторно применяет синтаксический анализатор p до тех пор пока p не потерпит неудачу, другими словами он \u0026ldquo;жадно\u0026rdquo; разбирает максимально возможное количество вхождений p. Результаты p возвращаются в виде списка в порядке появления.\nНесколько простых тестов показывают, что many floatInBrackets работает, как ожидалось:\n\u0026gt; test (many floatBetweenBrackets) \u0026quot;\u0026quot;;; Success: [] \u0026gt; test (many floatBetweenBrackets) \u0026quot;[1.0]\u0026quot;;; Success: [1.0] \u0026gt; test (many floatBetweenBrackets) \u0026quot;[2][3][4]\u0026quot;;; Success: [2.0; 3.0; 4.0]  Если в результате потребления входных данных floatBetweenBrackets вызывает исключение, то комбинированный синтаксический анализатор также вызывает исключение:\n\u0026gt; test (many floatBetweenBrackets) \u0026quot;[1][2.0E]\u0026quot;;; Failure: Error in Ln: 1 Col: 9 [1][2.0E] ^ Expecting: decimal digit  Обратите внимание, что many также успешно исполняется для пустой последовательности. Если вы хотите, чтобы требовался, по крайней мере, один элемент во входной последовательности, вы сможете использовать вместо этого many1:\n\u0026gt; test (many1 floatBetweenBrackets) \u0026quot;(1)\u0026quot;;; Failure: Error in Ln: 1 Col: 1 (1) ^ Expecting: '['   Если вы предпочитаете, чтобы последнее сообщение об ошибке было сформулировано в терминах более высокого уровневого синтаксического анализатора floatBetweenBrackets вместо низкоуровневого синтаксического анализатора str \u0026quot;[\u0026quot;, вы можете использовать оператор \u0026lt;?\u0026gt;, как в следующем примере:\n\u0026gt; test (many1 (floatBetweenBrackets \u0026lt;?\u0026gt; \u0026quot;float between brackets\u0026quot;)) \u0026quot;(1)\u0026quot;;; Failure: Error in Ln: 1 Col: 1 (1) ^ Expecting: float between brackets  Пожалуйста, смотрите главу 5.8 Customizing error messagesen руководства пользователя, чтобы узнать больше о настройке сообщений об ошибках.\n  Если вам не нужен результат работы синтаксического анализатора и просто хотите пропустить полученный список, вы можете использовать оптимизированные комбинаторы skipMany или skipMany1 вместо many и many1 .\nДругим часто используемым комбинатором для синтаксического разбора последовательностей является sepBy:\nval sepBy: Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'b,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a list, 'u\u0026gt;  sepBy принимает два параметра синтаксический анализатор «элемент» и «разделитель» и возвращает синтаксический анализатор для списка элементов. В нотации РНБН sepBy p pSep может быть записана как (p (pSep p)*)?, Подобно many, существует несколько вариантовen sepBy.\nС помощью sepBy мы можем сделать синтаксический разбор более реального формата списка чисел, где числа с плавающей точкой разделены запятой. Формате РНБН:\nfloatList: \u0026quot;[\u0026quot; (float (\u0026quot;,\u0026quot; float)*)? \u0026quot;]\u0026quot;  Допустимыми строками в этом формате являются, например: \u0026quot;[]\u0026quot;, \u0026quot;[1.0]\u0026quot;, \u0026quot;[2,3,4]\u0026quot;.\nДословной реализацией этого формата будет следующий синтаксический анализатор:\nlet floatList = str \u0026quot;[\u0026quot; \u0026gt;\u0026gt;. sepBy pfloat (str \u0026quot;,\u0026quot;) .\u0026gt;\u0026gt; str \u0026quot;]\u0026quot;  Тестирование floatList с корректными строками дает ожидаемый результат:\n\u0026gt; test floatList \u0026quot;[]\u0026quot;;; Success: [] \u0026gt; test floatList \u0026quot;[1.0]\u0026quot;;; Success: [1.0] \u0026gt; test floatList \u0026quot;[4,5,6]\u0026quot;;; Success: [4.0; 5.0; 6.0]  Тестирование с не корректными строками показывает, что floatList создает полезные сообщения об ошибках:\n\u0026gt; test floatList \u0026quot;[1.0,]\u0026quot;;; Failure: Error in Ln: 1 Col: 6 [1.0,] ^ Expecting: floating-point number \u0026gt; test floatList \u0026quot;[1.0,2.0\u0026quot;;; Failure: Error in Ln: 1 Col: 9 [1.0,2.0 ^ Note: The error occurred at the end of the input stream. Expecting: ',' or ']'  ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"cf51985ce720402abc22f965a3ce6db2","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/05-parsing-a-list-of-floats/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/05-parsing-a-list-of-floats/","section":"publication","summary":"Мы уже течение трех глав обсуждаем как делать синтаксический разбор одного числа с плавающей запятой, поэтому в этот раз мы попытаемся нечто более амбициозное: синтаксический разбор списка чисел с плавающей точкой.\nПредположим сначала, что нам нужно, чтобы делать синтаксический разбор последовательности чисел с плавающей точкой в скобках, т.е. текст в формате расширенной формы Бэкуса-Наура (далее РБНФ): (\u0026quot;[\u0026quot; float \u0026quot;]\u0026quot;)*. Допустимые входные строки в этом формате, например: \u0026quot;\u0026quot;, \u0026quot;[1.0]\u0026quot;, \u0026quot;[2][3][4]\u0026quot;.\nПоскольку у нас уже есть синтаксический анализатор для числа с плавающей точкой в скобках, нам нужен только способ неоднократно применять этот синтаксический анализатор для разбора последовательности.","tags":null,"title":"Глава 5. Синтаксический анализатор списка чисел с плавающей точкой","type":"publication"},{"authors":null,"categories":null,"content":"FParsec обрабатывает пробелы (пробелы, табуляции, новые строки и т. д.) Так же, как и любой другой ввод, поэтому наш синтаксический анализатор floatList еще не умеет работать с пробелами:\n\u0026gt; test floatBetweenBrackets \u0026quot;[1.0, 2.0]\u0026quot;;; Failure: Error in Ln: 1 Col: 5 [1.0, 2.0] ^ Expecting: ']'  Если мы хотим, чтобы синтаксический анализатор игнорировал пробелы, нам нужно сделать это явным образом.\nВо-первых, нам нужно определить, что мы хотим принять в качестве пробела. Для простоты мы просто используем встроенный синтаксическим анализатором spaces, который пропускает любую (возможно, пустую) последовательность символов ' ', '\\t' , '\\r' или '\\n'.\nlet ws = spaces  Затем нам нужно добавить синтаксический анализатор ws во все места, где мы хотим игнорировать пробелы. В общем случае удобно пропустить пробелы после вхождения отдельного элемента, т.е. Пропускать конечные, а не ведущие пробелы, потому что это уменьшает необходимость в обратной трассировке (подробнее см. ниже). В результате мы добавляем ws в два места, чтобы пропустить любые пробелы после скобок или цифр:\nlet str_ws s = pstring s .\u0026gt;\u0026gt; ws let float_ws = pfloat .\u0026gt;\u0026gt; ws let numberList = str_ws \u0026quot;[\u0026quot; \u0026gt;\u0026gt;. sepBy float_ws (str_ws \u0026quot;,\u0026quot;) .\u0026gt;\u0026gt; str_ws \u0026quot;]\u0026quot;  Простой тест показывает, что numberList игнорирует пробелы:\n\u0026gt; test numberList @\u0026quot;[ 1 , 2 ] \u0026quot;;; Success: [1.0; 2.0]  Если мы привнесем ошибку во второй строке, то увидим, что FParsec автоматически отслеживает текущее положение столбца и строки синтаксического анализа текста:\n\u0026gt; test numberList @\u0026quot;[ 1, 2; 3]\u0026quot;;; Failure: Error in Ln: 2 Col: 27 2; 3] ^ Expecting: ',' or ']'  Наш синтаксический анализатор numberList прежнему не пропускает ведущие пробелы, потому что это необязательно, когда мы сопоставляем его с другими синтаксическими анализаторами, которые пропускают все конечные пробелы. Если бы мы хотели разобрать весь поток ввода только с числами с плавающей запятой, мы могли бы использовать следующий синтаксический анализатор:\nlet numberListFile = ws \u0026gt;\u0026gt;. numberList .\u0026gt;\u0026gt; eof  Синтаксический анализатор конца файла eof будет генерировать ошибку, если конец потока не был достигнут. Это полезно для обеспечения того, чтобы весь входной поток был потреблен. Без анализатора eof следующий тест будет работать без ошибки:\n\u0026gt; test numberListFile \u0026quot; [1, 2, 3] [4]\u0026quot;;; Failure: Error in Ln: 1 Col: 12 [1, 2, 3] [4] ^ Expecting: end of input  ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"9a1ecae85883363ebdf72c51b35e92e6","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/06-handling-whitespace/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/06-handling-whitespace/","section":"publication","summary":"FParsec обрабатывает пробелы (пробелы, табуляции, новые строки и т. д.) Так же, как и любой другой ввод, поэтому наш синтаксический анализатор floatList еще не умеет работать с пробелами:\n\u0026gt; test floatBetweenBrackets \u0026quot;[1.0, 2.0]\u0026quot;;; Failure: Error in Ln: 1 Col: 5 [1.0, 2.0] ^ Expecting: ']'  Если мы хотим, чтобы синтаксический анализатор игнорировал пробелы, нам нужно сделать это явным образом.\nВо-первых, нам нужно определить, что мы хотим принять в качестве пробела.","tags":null,"title":"Глава 6. Обработка пробелов","type":"publication"},{"authors":null,"categories":null,"content":"FParsec содержит различные встроенные синтаксические анализаторы для символов, строк, чисел и пробелов. В этой главе мы представим несколько синтаксических анализаторов символов и строк. Обзор всех доступных синтаксических анализаторов см. в руководстве пользователяen.\nВы уже видели несколько применений синтаксического анализатора pstring (сокращенно str ), который просто пропускает строку определенного формата на входе. Когда синтаксический анализатор pstring успешно выполнился, он также возвращает пропущенную строку в качестве результата анализатора. Следующий пример демонстрирует это:\n\u0026gt; test (many (str \u0026quot;a\u0026quot; \u0026lt;|\u0026gt; str \u0026quot;b\u0026quot;)) \u0026quot;abba\u0026quot;;; Success: [\u0026quot;a\u0026quot;; \u0026quot;b\u0026quot;; \u0026quot;b\u0026quot;; \u0026quot;a\u0026quot;]  В этом примере мы так же использовали синтаксический анализатор \u0026lt;|\u0026gt; для объединения двух альтернативных анализаторов. Мы обсудим этот комбинатор более подробно ниже.\n Мы говорим, что pstring и pstring \u0026quot;a\u0026quot; это «синтаксические анализаторы». Но строго говоря, pstring - это функция, принимающая строку и возвращающая Parser, но удобнее про нее говорить как (параметрический) синтаксический анализатор.   Когда вам не нужен результат синтаксического анализатора pstring, вы можете в качестве альтернативы использовать синтаксический анализатор skipString, который возвращает unit значение () вместо строки аргумента. В приведенном примере для производительности не имеет значения, используете ли вы pstring или skipString, так как возвращаемая строка является константой. Однако для большинства других встроенных синтаксических анализаторов и комбинаторов вы должны предпочесть варианты с префиксом в имени skip, когда вам не нужны значения результата синтаксического анализатора, поскольку они, как правило, будут быстрее. Если вы посмотрите обзор библиотеки FParsecen, вы увидите варианты skip для многих встроенных синтаксических анализаторов и комбинаторов.\nЕсли вы хотите проанализировать строку без учета регистра, вы можете использовать pstringCIen и skipStringCIen. Например:\n\u0026gt; test (skipStringCI \u0026quot;\u0026lt;float\u0026gt;\u0026quot; \u0026gt;\u0026gt;. pfloat) \u0026quot;\u0026lt;FLOAT\u0026gt;1.0\u0026quot;;; Success: 1.0  Часто нужно разбирать строковые переменные, чьи символы должны удовлетворять определенным критериям. Например, идентификаторы в языках программирования часто должны начинаться с буквы или подчеркивания, а затем необходимо продолжать буквы, цифры или символы подчеркивания. Чтобы проанализировать такой идентификатор, вы можете использовать следующий синтаксический анализатор:\nlet identifier = let isIdentifierFirstChar c = isLetter c || c = '_' let isIdentifierChar c = isLetter c || isDigit c || c = '_' many1Satisfy2L isIdentifierFirstChar isIdentifierChar \u0026quot;identifier\u0026quot; .\u0026gt;\u0026gt; ws // Пропускает завершающие пробелы  Здесь мы использовали синтаксический анализатор many1Satisfy2Len, который является одним из нескольких примитивов для синтаксического анализа строк на основе предикатов символов (т.е. функций, которые принимают символ на входе и возвращают логическое значение). Он анализирует любую последовательность одного или нескольких символов (отсюда и many1 в имени), чей первый символ удовлетворяет первой предикатной функции, а остальные символы удовлетворяют второму предикату (отсюда Satisfy2). Строковая метка, указанная в качестве третьего аргумента (следовательно, L), используется в сообщении об ошибке для описания ожидаемого ввода.\nСледующие тесты показывают, как работает этот анализатор:\n\u0026gt; test identifier \u0026quot;_\u0026quot;;; Success: \u0026quot;_\u0026quot; \u0026gt; test identifier \u0026quot;_test1=\u0026quot;;; Success: \u0026quot;_test1\u0026quot; \u0026gt; test identifier \u0026quot;1\u0026quot;;; Failure: Error in Ln: 1 Col: 1 1 ^ Expecting: identifier   Если вы хотите анализировать идентификаторы на основе синтаксиса Unicode XIDen, рассмотрите возможность использования встроенного анализатора identifieren.   Многие строковые форматы достаточно сложны, поэтому вам нужно объединить несколько примитивов символьного синтаксического анализатора и строкового синтаксического анализатора. Например, рассмотрим следующий пример анализа строки в формате РНБН:\nnormalChar: any char except '\\' and '\u0026quot;' escapedChar: '\\\\' ('\\\\'|'\u0026quot;'|'n'|'r'|'t') stringLiteral: '\u0026quot;' ( normalChar | escapedChar )* '\u0026quot;'  Прямой перевод этой грамматики в FParsec выглядит так:\nlet stringLiteral = let normalChar = let anyCharExcept c = c \u0026lt;\u0026gt; '\\\\' \u0026amp;\u0026amp; c \u0026lt;\u0026gt; '\u0026quot;' satisfy anyCharExcept let escapedChar = let unescape c = match c with | 'n' -\u0026gt; '\\n' | 'r' -\u0026gt; '\\r' | 't' -\u0026gt; '\\t' | c -\u0026gt; c pstring \u0026quot;\\\\\u0026quot; \u0026gt;\u0026gt;. (anyOf \u0026quot;\\\\nrt\\\u0026quot;\u0026quot; |\u0026gt;\u0026gt; unescape) let quote = pstring \u0026quot;\\\u0026quot;\u0026quot; between quote quote ( manyChars (normalChar \u0026lt;|\u0026gt; escapedChar) )  В этом примере появилось несколько новых функций библиотеки. Давайте рассмотрим их подробнее:\n Функция satisfyen разбирает любой символ, который удовлетворяет заданному в параметрах предикату. Функция anyOfen разбирает любой символ, содержащийся в строке аргумента. Комбинатор конвейера |\u0026gt;\u0026gt;en применяет функцию с правой стороны (unescape) к результату синтаксического анализатора с левой стороны (anyOf \u0026quot;\\\\nrt\\\u0026quot;\u0026quot;). Комбинатор выбора \u0026lt;|\u0026gt;en применяет синтаксический анализатор с правой стороны, если синтаксический анализатор с левой стороны терпит неудачу, так что normalChar \u0026lt;|\u0026gt; escapedChar может анализировать как обычные, так и экранированные символы. (Мы обсудим этот комбинатор более подробно через две главы далее). Функция manyCharsen анализирует последовательность символов с заданным символьным синтаксическим анализатором и возвращает его как строку.  Давайте протестируем синтаксический анализатор stringLiteral:\n\u0026gt; test stringLiteral \u0026quot;\\\u0026quot;abc\\\u0026quot;\u0026quot;;; Success: \u0026quot;abc\u0026quot; \u0026gt; test stringLiteral \u0026quot;\\\u0026quot;abc\\\\\\\u0026quot;def\\\\\\\\ghi\u0026quot;;; Success: \u0026quot;abc\u0026quot;def\\ghi\u0026quot; \u0026gt; test stringLiteral \u0026quot;\\\u0026quot;abc\\\\def\\\u0026quot;\u0026quot;;; Failure: Error in Ln: 1 Col: 6 \u0026quot;abc\\def\u0026quot; ^ Expecting: any char in ‘\\nrt\u0026quot;’  Вместо разбора строкового литерала посимвольно мы могли бы также разобрать его построчно:\nlet stringLiteral2 = let normalString = let anyCharExcept c = c \u0026lt;\u0026gt; '\\\\' \u0026amp;\u0026amp; c \u0026lt;\u0026gt; '\u0026quot;' many1Satisfy anyCharExcept let escapedChar = let unescape c = match c with | 'n' -\u0026gt; '\\n' | 'r' -\u0026gt; '\\r' | 't' -\u0026gt; '\\t' | c -\u0026gt; c pstring \u0026quot;\\\\\u0026quot; \u0026gt;\u0026gt;. (anyOf \u0026quot;\\\\nrt\\\u0026quot;\u0026quot; |\u0026gt;\u0026gt; unescape) let quote = pstring \u0026quot;\\\u0026quot;\u0026quot; between quote quote ( manyStrings (normalString \u0026lt;|\u0026gt; escapedChar) )  Здесь мы использовали комбинатор manyStringsen , который анализирует последовательность строк с заданным синтаксическим анализатором строк и возвращает объединённую строку.\n Мы должны настроить синтаксический анализатор normalString что бы он требовал по крайней мере один символ, т.е. нужно использовать many1Satisfyen вместо manySatisfyen . В противном случае normalString успешно выполниться, даже если нет входных данных, escapedChar никогда не вызовется вызываться, а manyStringsen в конечном итоге вызовет исключение для предотвращения бесконечного цикла.   Синтаксический анализ строки с использованием оптимизированного синтаксического анализатора, такого как many1Satisfy, обычно немного быстрее, чем синтаксический анализ его с помощью manyChars и satisfy. В этом случае мы можем оптимизировать наш синтаксический анализатор еще немного - как только мы поймем, что два нормальных фрагмента строк должны быть разделены хотя бы одним экранированным символом:\nlet stringLiteral3 = let normalString = let anyCharExcept c = c \u0026lt;\u0026gt; '\\\\' \u0026amp;\u0026amp; c \u0026lt;\u0026gt; '\u0026quot;' manySatisfy anyCharExcept let escapedChar = let unescape c = match c with | 'n' -\u0026gt; '\\n' | 'r' -\u0026gt; '\\r' | 't' -\u0026gt; '\\t' | c -\u0026gt; c pstring \u0026quot;\\\\\u0026quot; \u0026gt;\u0026gt;. (anyOf \u0026quot;\\\\nrt\\\u0026quot;\u0026quot; |\u0026gt;\u0026gt; unescape) let quote = pstring \u0026quot;\\\u0026quot;\u0026quot; between quote quote ( stringsSepBy normalString escapedChar) )  Синтаксический анализатор stringsSepByen анализирует последовательность строк (первый аргумент), разделенных другими строками (второй аргумент). Он возвращает все разобранные строки, включая строки разделителя, в виде новой объединённой строки.\nОбратите внимание, что stringLiteral3 использует manySatisfyen вместо many1Satisfyen в своем определении normalString, так что он может анализировать экранированные символы, которые не разделены обычными символами. Это приведет к бесконечному циклу, потому что escapedChar не будет исполнено при отсутствии входных данных.\n","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"3cde193c1447a30b0d7ef09d53c64df8","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/07-parsing-string-data/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/07-parsing-string-data/","section":"publication","summary":"FParsec содержит различные встроенные синтаксические анализаторы для символов, строк, чисел и пробелов. В этой главе мы представим несколько синтаксических анализаторов символов и строк. Обзор всех доступных синтаксических анализаторов см. в руководстве пользователяen.\nВы уже видели несколько применений синтаксического анализатора pstring (сокращенно str ), который просто пропускает строку определенного формата на входе. Когда синтаксический анализатор pstring успешно выполнился, он также возвращает пропущенную строку в качестве результата анализатора. Следующий пример демонстрирует это:","tags":null,"title":"Глава 7. Синтаксический анализатор строковых данных","type":"publication"},{"authors":null,"categories":null,"content":"Всякий раз, когда вам нужно применять несколько синтаксических анализаторов в последовательности, а нужен только результат одного из них, подходящая комбинация \u0026gt;\u0026gt;.en и .\u0026gt;\u0026gt;en операторов поможет выполнить эту работу. Однако этих комбинаторов не хватит, если вам нужен результат более чем одного из задействованных синтаксических анализаторов. В этом случае вы можете использовать pipe2en, \u0026hellip;, pipe5en, которые последовательно применяют несколько синтаксических анализаторов и передают все отдельные результаты функции, которая вычисляет итоговый результат.\nНапример, с комбинатором pipe2en\nval pipe2: Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'b,'u\u0026gt; -\u0026gt; ('a -\u0026gt; b -\u0026gt; 'c) -\u0026gt; Parser\u0026lt;'c,'u\u0026gt;  Вы можете построить синтаксический анализатор pipe2 p1 p2 f который последовательно применяет два синтаксических анализатора p1 и p2, а затем возвращает результат применения функции f x1 x2, где x1 и x2 - результаты, возвращаемые p1 и p2.\nВ следующем примере мы используем pipe2en для синтаксического анализа произведения из двух чисел:\nlet product = pipe2 float_ws (str_ws \u0026quot;*\u0026quot; \u0026gt;\u0026gt;. float_ws) (fun x y -\u0026gt; x * y)  \u0026gt; test product \u0026quot;3 * 5\u0026quot;;; Success: 15.0  pipe2-5 особенно полезны для построения объектов Абстрактного синтаксического дерева (далее АСТ). В следующем примере мы используем pipe3en для анализа определения строковой константы в объекте StringConstant:\ntype StringConstant = StringConstant of string * string let stringConstant = pipe3 identifier (str_ws \u0026quot;=\u0026quot;) stringLiteral (fun id _ str -\u0026gt; StringConstant(id, str))  \u0026gt; test stringConstant \u0026quot;myString = \\\u0026quot;stringValue\\\u0026quot;\u0026quot;;; Success: StringConstant (\u0026quot;myString\u0026quot;,\u0026quot;stringValue\u0026quot;)  Если вы просто хотите вернуть проанализированные значения в виде кортежа, вы можете использовать предопределенные функции tuple2en\u0026hellip;tuple5en. Например, tuple2 p1 p2 эквивалентен pipe2 p1 p2 ( fun x1 x2 -\u0026gt; ( x1 , x2 ) ).\nСинтаксический анализатор tuple2en также доступен в виде комбинатора .\u0026gt;\u0026gt;.en. Так что вы можете написать p1 .\u0026gt;\u0026gt;. p2 вместо tuple2 p1 p2. В следующем примере мы проанализируем пару разделенных запятыми чисел с этим оператором:\n\u0026gt; test (float_ws .\u0026gt;\u0026gt;. (str_ws \u0026quot;,\u0026quot; \u0026gt;\u0026gt;. float_ws)) \u0026quot;123, 456\u0026quot;;; Success: (123.0, 456.0)  Надеемся, что вы уже интуитивно понимаете шаблон записи \u0026gt;\u0026gt;одна-или-две-точки.\nЕсли вам нужен синтаксический анализатор pipe или tuple более чем c пятью аргументами, вы можете легко построить его с помощью существующих. Например, у вас есть идея: определить синтаксический анализатор pipe7.\nlet pipe7 p1 p2 p3 p4 p5 p6 p7 f = pipe4 p1 p2 p3 (tuple4 p4 p5 p6 p7) (fun x1 x2 x3 (x4, x5, x6, x7) -\u0026gt; f x1 x2 x3 x4 x5 x6 x7)  ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"f0e863fc2223f7d356bf2e9a40c07838","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/08-sequentially-applying-parsers/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/08-sequentially-applying-parsers/","section":"publication","summary":"Всякий раз, когда вам нужно применять несколько синтаксических анализаторов в последовательности, а нужен только результат одного из них, подходящая комбинация \u0026gt;\u0026gt;.en и .\u0026gt;\u0026gt;en операторов поможет выполнить эту работу. Однако этих комбинаторов не хватит, если вам нужен результат более чем одного из задействованных синтаксических анализаторов. В этом случае вы можете использовать pipe2en, \u0026hellip;, pipe5en, которые последовательно применяют несколько синтаксических анализаторов и передают все отдельные результаты функции, которая вычисляет итоговый результат.\nНапример, с комбинатором pipe2en","tags":null,"title":"Глава 8. Использование последовательности синтаксических анализаторов","type":"publication"},{"authors":null,"categories":null,"content":"В главе 7 \u0026ldquo;Синтаксический анализатор строковых данных\u0026rdquo; мы вкратце представили комбинатор выбора \u0026lt;|\u0026gt;en :\nval (\u0026lt;|\u0026gt;): Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a,u\u0026gt;  Этот комбинатор позволяет вам поддерживать несколько альтернативных вариантов.\nНапример, в главе 7 мы использовали \u0026lt;|\u0026gt; для объединения синтаксического анализатора для неэкранированных символов и анализатора для экранированных символов в новый анализатор, который поддерживает оба варианта: normalChar \u0026lt;|\u0026gt; escapedChar.\nДругим примером, показывающим, как работает \u0026lt;|\u0026gt; является следующий синтаксический анализатор для разбора строкового представления булевых значений:\nlet boolean = (stringReturn \u0026quot;true\u0026quot; true) \u0026lt;|\u0026gt; (stringReturn \u0026quot;false\u0026quot; false)  Здесь мы использовали синтаксический анализатор stringReturnen, который берет в качестве первого аргумента строку, и, в случае успеха, возвращает значение, указанное в качестве второго аргумента.\nПротестируем синтаксический анализатор boolean на примерах:\n\u0026gt; test boolean \u0026quot;false\u0026quot;;; Success: false \u0026gt; test boolean \u0026quot;true\u0026quot;;; Success: true \u0026gt; test boolean \u0026quot;tru\u0026quot;;; Failure: Error in Ln: 1 Col: 1 tru ^ Expecting: 'false' or 'true'  Поведение комбинатора \u0026lt;|\u0026gt; имеет две важные характеристики: * \u0026lt;|\u0026gt; Правая часть синтаксического анализатора выполняется, если синтаксический анализатор левой части завершился с не фатальной ошибкой и без изменения состояния. Комбинатор не реализует правило самого длинного совпадения. * Однако, комбинатор пытается использовать правый синтаксический анализатор, если левый синтаксический анализатор при завершении вызывает нет данных для обработки.\nСледствием второго пункта является то, что следующий тест завершился неудачно, потому что синтаксический анализатор в левой части \u0026lt;|\u0026gt; получает пробелы перед сбоем:\n\u0026gt; test ((ws \u0026gt;\u0026gt;. str \u0026quot;a\u0026quot;) \u0026lt;|\u0026gt; (ws \u0026gt;\u0026gt;. str \u0026quot;b\u0026quot;)) \u0026quot; b\u0026quot;;; Failure: Error in Ln: 1 Col: 2 b ^ Expecting: 'a'  К счастью, мы можем легко исправить этот синтаксический анализатор, выделив ws:\n\u0026gt; test (ws \u0026gt;\u0026gt;. (str \u0026quot;a\u0026quot; \u0026lt;|\u0026gt; str \u0026quot;b\u0026quot;)) \u0026quot; b\u0026quot;;; Success: \u0026quot;b\u0026quot;  Если вам интересно, почему \u0026lt;|\u0026gt; ведет себя таким образом и как вы можете обрабатывать ситуации, в которых вам нужно чтобы \u0026lt;|\u0026gt; пытался исполнять альтернативный синтаксический анализатор, даже если первый синтаксический анализатор вызвал ошибку после обработки входных данных смотрите главы 5.6 Parsing alternatives и 5.7 Looking ahead and backtracking в руководстве пользователя.\nЕсли вы хотите использовать более двух альтернативных синтаксических анализаторов, вы можете комбинировать несколько операторов \u0026lt;|\u0026gt;, например, в p1 \u0026lt;|\u0026gt; p2 \u0026lt;|\u0026gt; p3 \u0026lt;|\u0026gt; ..., или вы можете использовать комбинатор choiceen, который принимает последовательность синтаксических анализаторов в качестве аргумента, например choice [ p1 ; p2 ; p3 ; ... ].\n","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"5e1de5168da77b89926098362dbff451","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/09-parsing-alternatives/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/09-parsing-alternatives/","section":"publication","summary":"В главе 7 \u0026ldquo;Синтаксический анализатор строковых данных\u0026rdquo; мы вкратце представили комбинатор выбора \u0026lt;|\u0026gt;en :\nval (\u0026lt;|\u0026gt;): Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a,'u\u0026gt; -\u0026gt; Parser\u0026lt;'a,u\u0026gt;  Этот комбинатор позволяет вам поддерживать несколько альтернативных вариантов.\nНапример, в главе 7 мы использовали \u0026lt;|\u0026gt; для объединения синтаксического анализатора для неэкранированных символов и анализатора для экранированных символов в новый анализатор, который поддерживает оба варианта: normalChar \u0026lt;|\u0026gt; escapedChar.\nДругим примером, показывающим, как работает \u0026lt;|\u0026gt; является следующий синтаксический анализатор для разбора строкового представления булевых значений:","tags":null,"title":"Глава 9. Использование альтернативных синтаксических анализов","type":"publication"},{"authors":null,"categories":null,"content":"Когда вы начинаете писать собственные синтаксические анализаторы с помощью библиотеки FParsec или пытаетесь скомпилировать некоторые отдельные фрагменты кода из учебника, вы столкнетесь с особенностями компилятора, которые часто вызывают некоторые затруднения среди новых пользователей F# и FParsec: ограничение значений. В этом разделе мы объясним ограничение значений и способ его обработки в ваших программах FParsec.\n Если вы найдете содержимое главы слишком техническим на данный момент, просто перейдите к следующей главе и вернитесь позже, когда вы в первый раз увидите сообщение компилятора, в котором упоминается value restriction.   Ограничение значений F# является причиной того, что следующий фрагмент кода не компилируется\nopen FParsec let p = pstring \u0026quot;test\u0026quot;  Но следующий фрагмент скомпилирован без проблем (Предполагаем, что вы ссылались на две библиотеки FParsec):\nopen FParsec let p = pstring \u0026quot;test\u0026quot; run p \u0026quot;input\u0026quot;  Ошибка компилятора, сгенерированная для первого примера будет примерно следующая:\nerror FS0030: Value restriction. The value 'p' has been inferred to have generic type val p : Parser\u0026lt;string,'_a\u0026gt; Either make the arguments to 'p' explicit or, if you do not intend for it to be generic, add a type annotation.  Когда вы работаете с библиотекой FParsec, вы рано или поздно увидите это или похожие сообщения об ошибке, в частности, если вы работаете в интерактивной консоли. К счастью для ошибок такого рода, как правило, легко найти обходной путь.\nПроблема с первым примером выше заключается в том, что компилятор F# выводит значение p как имеющее неопределенное значение общего типа, хотя F# не допускает значение общего типа в этой ситуации. Функция pstring возвращает значение типа Parser\u0026lt;string, 'u\u0026gt;, где 'u - параметр типа представляющий собой пользовательское состояние типа CharStream. Так как в первом примере выше, нет значений содержащих этот параметр типа, компилятор указывает тип результата как Parser\u0026lt;string, '_a\u0026gt; для синтаксического анализатора p, где '_a представляет не определенный параметр общего типа.\nВо втором примере эта проблема не возникает, поскольку использование p в качестве первого аргумента функции run определяет тип пользовательского состояния. Поскольку run принимает только синтаксические анализаторы типа Parser\u0026lt;'t, unit\u0026gt;, компилятор выводит определенный тип Parser\u0026lt;string, unit\u0026gt; для p.\nВ примере ниже предлагается два способа обработки ограничения значений в программах FParsec:\n Либо убедитесь, что тип значения синтаксического анализатора ограничен не обобщенным типом путем дальнейшего использования значения этого синтаксического анализатора в одном блоке компиляции, Или предоставьте явную аннотацию типа, чтобы вручную ограничивать тип значения синтаксического анализатора (обычно для всего модуля синтаксического анализа достаточно нескольких аннотаций типа в ключевых точках).  Часто бывает удобно определить аббревиатуры типа следующего вида:\ntype UserState = unit // Конечно не обязательно должен быть unit типом type Parser\u0026lt;'t\u0026gt; = Parser\u0026lt;'t, UserState\u0026gt;  С такими аббревиатурами, типы аннотаций становятся такими же простыми, как\nlet p : Parser\u0026lt;_\u0026gt; = pstring \u0026quot;test\u0026quot;  Конечно, ограничение значения типа синтаксического анализатора до определенного типа - это только решение, если вам действительно не нужен общий тип. Если вам нужен общий тип, вам придется применять другие методы, как это описано, например, в документации по языку F# или в статье Finer Points of F# Value Restrictionen в блоге Дмитрия Ломова. Однако значения Parser FParsec (непараметрические функции синтаксического анализатора) обычно используются только в контексте конкретного использования синтаксического анализатора с фиксированным типом состояния пользователя. В этой ситуации ограничение типа действительно является подходящей мерой, чтобы избежать ошибок ограничения значения.\n","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"fd977aad4d999fcb7337c186e200c4ff","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/10-fsharps-value-restriction/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/10-fsharps-value-restriction/","section":"publication","summary":"Когда вы начинаете писать собственные синтаксические анализаторы с помощью библиотеки FParsec или пытаетесь скомпилировать некоторые отдельные фрагменты кода из учебника, вы столкнетесь с особенностями компилятора, которые часто вызывают некоторые затруднения среди новых пользователей F# и FParsec: ограничение значений. В этом разделе мы объясним ограничение значений и способ его обработки в ваших программах FParsec.\n Если вы найдете содержимое главы слишком техническим на данный момент, просто перейдите к следующей главе и вернитесь позже, когда вы в первый раз увидите сообщение компилятора, в котором упоминается value restriction.","tags":null,"title":"Глава 10. Ограничение значений F#","type":"publication"},{"authors":null,"categories":null,"content":"Now that we have discussed the basics of FParsec we are well prepared to work through a real world parser example: a JSON parser.\nJSON (JavaScript Object Notation) is a text-based data interchange format with a simple and lightweight syntax. You can find descriptions of the syntax on json.org and in RFC 4626.\nIn many applications one only has to deal with JSON files describing one particular kind of object. In such a context it sometimes can be appropriate to write a specialized parser just for that specific kind of JSON file. In this tutorial, however, we will follow a more general approach. We will implement a parser that can parse any general JSON file into an AST, i.e. an intermediate data structure describing the contents of the file. Applications can then conveniently query this data structure and extract the information they need. This is an approach comparable to that of XML parsers which build a data structure describing the document tree of an XML document. The great advantage of this approach is that the JSON parser itself becomes reusable and the document specific parsing logic can be expressed in the form of simple functions processing the AST of the JSON document.\nThe natural way to implement an AST in F# is with the help of a discriminated union type. If you look at the JSON specification, you can see that a JSON value can be a string, a number, a boolean, null, a comma-separated list of values in square brackets, or an object with a sequence of key-value pairs in curly brackets.\nIn our parser we will use the following union type to represent JSON values:\ntype Json = JString of string | JNumber of float | JBool of bool | JNull | JList of Json list | JObject of Map\u0026lt;string, Json\u0026gt;  Here we\u0026rsquo;ve chosen the F# list type to represent a sequence of values and the Map type to represent a sequence of key-value pairs, because these types are particularly convenient to process in F#.[fn If you need to parse huge sequences and objects, it might be more appropriate to use an array and dictionary for JList and JObject respectively.] Note that the Json type is recursive, since both JList and JObject values can themselves contain Json values. Our parser will have to reflect this recursive structure.\n###Tip If you\u0026rsquo;re new to FParsec and have a little time, it would be a good exercise to try to implement the JSON parser on your own (with the help of the reference documentation). This tutorial already covered almost everything you need and the JSON grammar is simple enough that this shouldn\u0026rsquo;t take too much time. Of course, you can always peek at the implementation below if you get stuck.\nWe start the actual parser implementation by covering the simple null and boolean cases:\nlet jnull = stringReturn \u0026quot;null\u0026quot; JNull let jool = (stringReturn \u0026quot;true\u0026quot; (JBool true)) \u0026lt;|\u0026gt; (stringReturn \u0026quot;false\u0026quot; (JBool false))  Handling the number case is just as simple, because the JSON number format is based on the typical floating-point number format used in many programming languages and hence can be parsed with FParsec\u0026rsquo;s built-in pfloat parser:\nlet jnumber = pfloat |\u0026gt;\u0026gt; JNumber  (Note that F# allows us to pass the object constructor JNumber as a function argument.)\nIf you compare the precise number format supported by pfloat with that in the JSON spec, you\u0026rsquo;ll see that pfloat supports a superset of the JSON format. In contrast to the JSON format the pfloat parser also recognizes NaN and Infinity values, accepts a leading plus sign, accepts leading zeros and even supports the hexadecimal float format of Java and C99. Depending on the context this behaviour can be considered a feature or a limitation of the parser. For most applications it probably doesn\u0026rsquo;t matter, and the JSON RFC clearly states that a JSON parser may support a superset of the JSON syntax. However, if you\u0026rsquo;d rather only support the exact JSON number format, you can implement such a float parser rather easily based on the configurable numberLiteral parser (just have a look at how this is currently done in the pfloat source).\nThe JSON string format takes a little more effort to implement, but we\u0026rsquo;ve already parsed a similar format with the stringLiteral parsers in Parsing string data, so we can just adapt one of those parsers for our purpose:\nlet stringLiteral = let escape = anyOf \u0026quot;\\\u0026quot;\\\\/bfnrt\u0026quot; |\u0026gt;\u0026gt; function | 'b' -\u0026gt; \u0026quot;\\b\u0026quot; | 'f' -\u0026gt; \u0026quot;\\u000C\u0026quot; | 'n' -\u0026gt; \u0026quot;\\n\u0026quot; | 'r' -\u0026gt; \u0026quot;\\r\u0026quot; | 't' -\u0026gt; \u0026quot;\\t\u0026quot; | c -\u0026gt; string c // every other char is mapped to itself let unicodeEscape = /// converts a hex char ([0-9a-fA-F]) to its integer number (0-15) let hex2int c = (int c \u0026amp;\u0026amp;\u0026amp; 15) + (int c \u0026gt;\u0026gt;\u0026gt; 6)*9 str \u0026quot;u\u0026quot; \u0026gt;\u0026gt;. pipe4 hex hex hex hex (fun h3 h2 h1 h0 -\u0026gt; (hex2int h3)*4096 + (hex2int h2)*256 + (hex2int h1)*16 + hex2int h0 |\u0026gt; char |\u0026gt; string ) let escapedCharSnippet = str \u0026quot;\\\\\u0026quot; \u0026gt;\u0026gt;. (escape \u0026lt;|\u0026gt; unicodeEscape) let normalCharSnippet = manySatisfy (fun c -\u0026gt; c \u0026lt;\u0026gt; '\u0026quot;' \u0026amp;\u0026amp; c \u0026lt;\u0026gt; '\\\\') between (str \u0026quot;\\\u0026quot;\u0026quot;) (str \u0026quot;\\\u0026quot;\u0026quot;) (stringsSepBy normalCharSnippet escapedCharSnippet)  stringLiteral parses string literals as a sequence of normal char snippets separated by escaped char snippets. A normal char snippet is any sequence of chars that does not contain the chars '\u0026quot;' and '\\\\'. An escaped char snippet consists of a backslash followed by any of the chars '\\\\', '\\\u0026quot;', '/', 'b', 'f', 'n', 'r', 't', or an Unicode escape. An Unicode escape consists of an 'u' followed by four hex chars representing an UTF-16 code point.\n[#createParserForwardedToRef-example] The grammar rules for JSON lists and objects are recursive, because any list or object can contain itself any kind of JSON value. Hence, in order to write parsers for the list and object grammar rules, we need a way to refer to the parser for any kind of JSON value, even though we haven\u0026rsquo;t yet constructed this parser. Like it is so often in computing, we can solve this problem by introducing an extra indirection:\nlet jvalue, jvalueRef = createParserForwardedToRef\u0026lt;Json, unit\u0026gt;()  As you might have guessed from the name, createParserForwardedToRef creates a parser (jvalue) that forwards all invocations to the parser in a reference cell (jvalueRef). Initially, the reference cell holds a dummy parser, but since the reference cell is mutable, we can later replace the dummy parser with the actual value parser, once we have finished constructing it.\nThe JSON RFC sensibly only permits spaces, (horizontal) tabs, line feeds and carriage returns as whitespace characters, which allows us to use the built-in spaces parser for parsing whitespace:\nlet ws = spaces  Both JSON lists and objects are syntactically represented as a comma-separated lists of \u0026ldquo;elements\u0026rdquo; between brackets, where whitespace is allowed before and after any bracket, comma and list element. We can conveniently parse such lists with the following helper function:\nlet listBetweenStrings sOpen sClose pElement f = between (str sOpen) (str sClose) (ws \u0026gt;\u0026gt;. sepBy (pElement .\u0026gt;\u0026gt; ws) (str \u0026quot;,\u0026quot; \u0026gt;\u0026gt;. ws) |\u0026gt;\u0026gt; f)  This function takes four arguments: an opening string, a closing string, an element parser and a function that is applied to the parsed list of elements.\nWith the help of this function we can define the parser for a JSON list as follows:\nlet jlist = listBetweenStrings \u0026quot;[\u0026quot; \u0026quot;]\u0026quot; jvalue JList  JSON objects are lists of key-value pairs, so we need a parser for a key-value pair:\nlet keyValue = stringLiteral .\u0026gt;\u0026gt;. (ws \u0026gt;\u0026gt;. str \u0026quot;:\u0026quot; \u0026gt;\u0026gt;. ws \u0026gt;\u0026gt;. jvalue)  (Remember, the points on both sides of .\u0026gt;\u0026gt;. indicate that the results of the two parsers on both sides are returned as a tuple.)\nBy passing the keyValue parser to listBetweenStrings we obtain a parser for JSON objects:\nlet jobject = listBetweenStrings \u0026quot;{\u0026quot; \u0026quot;}\u0026quot; keyValue (Map.ofList \u0026gt;\u0026gt; JObject)  [#json-value-parser] Having defined parsers for all the possible kind of JSON values, we can combine the different cases with a choice parser to obtain the finished parser for JSON values:\ndo jvalueRef := choice [jobject jlist jstring jnumber jtrue jfalse jnull]  The jvalue parser doesn\u0026rsquo;t accept leading or trailing whitespace, so we need to define our parser for complete JSON documents as follows:\nlet json = ws \u0026gt;\u0026gt;. jvalue .\u0026gt;\u0026gt; ws .\u0026gt;\u0026gt; eof  This parser will try to consume a complete JSON input stream and, if successful, will return a Json AST of the input as the parser result\nAnd that\u0026rsquo;s it, we\u0026rsquo;re finished with our JSON parser. If you want to try this parser out on some sample input, please take a look at the JSON project in the Samples folder.\n","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"139f25d3ea7281818ded510655ee70d8","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/11-parsing-json/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/11-parsing-json/","section":"publication","summary":"Now that we have discussed the basics of FParsec we are well prepared to work through a real world parser example: a JSON parser.\nJSON (JavaScript Object Notation) is a text-based data interchange format with a simple and lightweight syntax. You can find descriptions of the syntax on json.org and in RFC 4626.\nIn many applications one only has to deal with JSON files describing one particular kind of object. In such a context it sometimes can be appropriate to write a specialized parser just for that specific kind of JSON file.","tags":null,"title":"Глава 11. Синтаксический анализ JSON","type":"publication"},{"authors":null,"categories":null,"content":"If this tutorial has whet your appetite for a more in-depth introduction to FParsec, just head over to the user\u0026rsquo;s guide. If you can\u0026rsquo;t wait to write your own parser, then bookmark the parser overview page, maybe take a short look at the example parsers in the Samples folder and just start hacking. You can always consult the user\u0026rsquo;s guide at a later point should you get stuck somewhere.\n","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"5d4fa8748148411cafe182ac5b6de349","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/12-what-now/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/12-what-now/","section":"publication","summary":"If this tutorial has whet your appetite for a more in-depth introduction to FParsec, just head over to the user\u0026rsquo;s guide. If you can\u0026rsquo;t wait to write your own parser, then bookmark the parser overview page, maybe take a short look at the example parsers in the Samples folder and just start hacking. You can always consult the user\u0026rsquo;s guide at a later point should you get stuck somewhere.","tags":null,"title":"Глава 12. Куда дальше?","type":"publication"},{"authors":null,"categories":null,"content":" Встроенные средства языка  В этом варианте используем встроенную в язык функцию #table. Функция принимает два варианта параметров:  Первый параметр список имен полей, Второй список списков записей таблицы (см. Создание таблицы на основании списка полей) Первый параметр тип описывающий тип таблицы в виде перечисления в записи имен полей и их типов, Второй параметр список списков записей таблицы (см. Создание таблицы на основании ее типа).\n   \nСоздание таблицы на основании списка полей Используем этот вариант если мы хотим создать таблицу и просто знаем какой то перечень полей и примерные значения для нее.\n Мы можем просто определить таблицу и передав пустой список вторым параметром просто создать пустую таблицу\n#table( // Список имен полей { \u0026quot;Digit\u0026quot;, \u0026quot;Name\u0026quot; }, // Пустой список {} )  Или добавить какие то статические данные:\n#table( // Список имен полей { \u0026quot;Digit\u0026quot;, \u0026quot;Name\u0026quot; }, // Список списков записей таблицы { {1,\u0026quot;one\u0026quot;}, {2,\u0026quot;two\u0026quot;}, {3,\u0026quot;three\u0026quot;} } )   \nСоздание таблицы на основании ее типа Используем этот вариант если мы хотим создать таблицу и уже на первом этапе определить с какими типами полей в дальнейшем мы хотим работать.\n Мы можем просто определить таблицу и передав пустой список вторым параметром просто создать пустую таблицу\n#table( // Тип описывающий таблицу через определения в записи типов ее полей: type table [Digit = number, Name = text], // Пустой список {} } )  Или добавить какие то статические данные:\n#table( // Тип описывающий таблицу через определения в записи типов ее полей: type table [Digit = number, Name = text], // Список списков записей таблицы { {1,\u0026quot;one\u0026quot;}, {2,\u0026quot;two\u0026quot;}, {3,\u0026quot;three\u0026quot;} } )   Использованные источники  Power Query M language specification  ","date":1539734400,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1539734400,"objectID":"b273e9214f3569bb57f3d15a072554c1","permalink":"https://DmitriyVlasov.ru/ru/post/how-to-create-a-table-on-power-query/","publishdate":"2018-10-17T00:00:00Z","relpermalink":"/ru/post/how-to-create-a-table-on-power-query/","section":"post","summary":"Встроенные средства языка  В этом варианте используем встроенную в язык функцию #table. Функция принимает два варианта параметров:  Первый параметр список имен полей, Второй список списков записей таблицы (см. Создание таблицы на основании списка полей) Первый параметр тип описывающий тип таблицы в виде перечисления в записи имен полей и их типов, Второй параметр список списков записей таблицы (см. Создание таблицы на основании ее типа).","tags":["Power BI","Power Query","Вопросы и Ответы"],"title":"Как на Power Query создать таблицу?","type":"post"},{"authors":null,"categories":null,"content":" Предисловие После установки августовского релиза Power BI  я очень обрадовался, увидев поддержку Python. Как раз в работе оказался проект, в котором возможность поддержки Python помогла реализовать требования заказчика. Нужно было подключаться к API, предварительно зашифровывая тело запроса открытым и закрытым ключём, перед отправлением запроса к API. К сожалению, как оказалось, поддержка шифрования в Power BI есть только в кастомных дата коннекторах, и отсутствует в Power Query для Power BI Desktop. А при всем моем теплом отношении к языку R, связываться с ним лишний раз, мне бы не хотелось. Поэтому поддержке Python в Power BI я был рад очень.\nЗадача  Настроить управление поведением скрипта на Python через параметры отчета Power BI Desktop.  Демонстрационный отчет в Power BI Online  Описание решения Предварительные требования  У вас установлена Anaconda В Power BI включена поддержка Python Запуск в терминале jupyter notebook Откройте перед глазами памятку по Python  Подготовка в Power BI  В файле Power BI создаем параметры отчета. Оборачиваем параметры отчета в таблицу с необходимой структурой. Если используются параметры типа date/datetime, то предварительно их приводим к строке:\nlet Parameters = Table.FromRows( { { Date.ToText( FromDate, \u0026quot;dd.MM.yyyy\u0026quot; ), Date.ToText( ToDate, \u0026quot;dd.MM.yyyy\u0026quot; ) } }, type table [ FromDate = text, ToDate = text ] ) in Parameters   Разработка скрипта Python В моем примере скрипт на Python будем разрабатывать в инструменте, популярном у аналитиков данных Jupyter Notebook.\n Создаем файл блокнота. Импортируем библиотеку работы с таблицами Pandas (структура аналогичная объекту Table в Power BI)  import pandas as pd   Объявляем переменную Parameters повторяющую структуру, таблицы с параметрами на Power Query (см. выше), это необходимо для отладки и проверки работоспособности скрипта.  import pandas as pd FromDate = \u0026quot;01.07.2018\u0026quot; ToDate = \u0026quot;31.07.2018\u0026quot; Parameters = pd.DataFrame( [ [ FromDate, ToDate ] ], columns = ['FromDate','ToDate'] )   В рамках рассмотренного примера для простоты работы внутри скрипта на Python вручную создается таблица, а затем с помощью переданных параметров таблица отфильтровывается. Полученный результат далее возвращается в Power BI и может использоваться для дальнейшего анализа.\n  Далее реализовываем логику обработки скрипта. Для удобства переноса разработанного скрипта, обработки снова объявляем импорт библиотеки Pandas.  import pandas as pd   Помним о том, что мы передали параметры в формате даты времени в текстовом формате ( объяснение подробнее см ниже )  Parameters['FromDate'] = pd.to_datetime( Parameters['FromDate'], format=\u0026quot;%d.%m.%Y\u0026quot; ) Parameters['ToDate'] = pd.to_datetime( Parameters['ToDate'], format=\u0026quot;%d.%m.%Y\u0026quot; )   Если вам нужно настроить преобразование строки под ваш формат даты времени, то вы можете использовать для этого таблицу кодов форматов для 2 или 3 Питона соответственно.\n  Получаем данные из внешней системы. Для демо примера создаем вручную таблицу в Pandas  Sales = pd.DataFrame( [ [\u0026quot;01.07.2018\u0026quot;, 10], [\u0026quot;01.08.2018\u0026quot;, 20], [\u0026quot;01.09.2018\u0026quot;, 30] ], columns=['Date', 'Amount' ] )   Для корректной работы сортировки и фильтрации данных по столбцу даты времени приводим, в исследуемых таблицах столбец к дате.\n  Sales['Date'] = pd.to_datetime(Sales['Date'],format=\u0026quot;%d.%m.%Y\u0026quot;)   Применяем бизнес правила полученные от клиента и параметры, полученные из Power BI, к полученной в скрипте таблице  Result = Sales[ Sales['Date'] \u0026gt; Parameters['FromDate'][0] ]   Средствами Jupyter Notebook мы можем отладить и проверить полученные данные перед копированием полученного сприпта в Power BI.\n В результате получаем скрипт, подготовленный для передачи в Power BI\n  # Импортируем библиотеку работы с таблицами Pandas import pandas as pd # Готовим параметры для использования # Так как параметры даты, времени внутрь Python из Power BI передаются не совсем корректно (с ошибкой). # Удобно параметры даты передать в строковом виде, а затем привести обрратно в дате. Parameters['FromDate'] = pd.to_datetime( Parameters['FromDate'], format=\u0026quot;%d.%m.%Y\u0026quot; ) Parameters['ToDate'] = pd.to_datetime( Parameters['ToDate'], format=\u0026quot;%d.%m.%Y\u0026quot; ) # Получаем данные из внешней системы. Для демо примера просто создаем вручную таблицу в Pandas Sales = pd.DataFrame( [ [\u0026quot;01.07.2018\u0026quot;, 10], [\u0026quot;01.08.2018\u0026quot;, 20], [\u0026quot;01.09.2018\u0026quot;, 30] ], columns=['Date', 'Amount' ] ) Sales['Date'] = pd.to_datetime(Sales['Date'],format=\u0026quot;%d.%m.%Y\u0026quot;) # Применяем бизнес правила и параметры полученные из Power BI к таблице и возвращаем результат Result = Sales[ Sales['Date'] \u0026gt; Parameters['FromDate'][0] ]  Вызов скрипта на Python из Power BI  Так как, на данный момент, в мастере создания скрипта на Python в Power BI нет возможности передать не обязательные параметры, для простоты создаем минимально рабочий пример для создания корректного запроса Power Query, который затем обновим разработанным выше скриптом.  import pandas as pd Dummy = pd.DataFrame( [ [ \u0026quot;\u0026quot; ] ], columns = ['Dummy'] )   В мастере создания запросов Power BI Desktop, выбираем из раскрывающегося списка скрипт на Python. Передам минимальный скрипт на Python написанный выше. В мастере выбираем флажком таблицу Dummy и нажимаем OK. Скрипт будет успешно создан. Для передачи параметров нам придется перейти в расширенный редактор Power Query, где мы увидим следующий текст:\nlet Source = Python.Execute(\u0026quot;import pandas as pd#(lf)#(lf)Dummy = pd.DataFrame( [ [ \u0026quot;\u0026quot;\u0026quot;\u0026quot; ] ], columns = ['Dummy'] )#(lf)\u0026quot;), Dummy1 = Source{[Name=\u0026quot;Dummy\u0026quot;]}[Value] in Dummy1  Последний шаг навигации нам пока что не нужен, уберем его.\nlet Source = Python.Execute(\u0026quot;import pandas as pd#(lf)#(lf)Dummy = pd.DataFrame( [ [ \u0026quot;\u0026quot;\u0026quot;\u0026quot; ] ], columns = ['Dummy'] )#(lf)\u0026quot;) in Source  Передадим параметры из Power Query в пустой скрипт. С помощью ручного редактирования в расширенном редакторе Power Query добавим второй параметр вида [ Parameters = Parameters ].\n В результате получится следующий запроса на Power Query:\nlet Source = Python.Execute(\u0026quot;import pandas as pd#(lf)#(lf)Dummy = pd.DataFrame( [ [ \u0026quot;\u0026quot;\u0026quot;\u0026quot; ] ], columns = ['Dummy'] )#(lf)\u0026quot;, [ Parameters = Parameters ]) in Source  Power Query предупредит что мы изменили определение скрипта. Мы должны согласиться с изменениями. В результате нам будет доступно для навигации две записи каждая из которых содержит таблицу.\n Отредактируем с помощью мастера запрос и вставим разработанный на предыдущем шаге скрипт, нажав на шестеренку напросив пункта Source.\n В результате получится следующий запроса на Power Query:\nlet Source = Python.Execute(\u0026quot;import pandas as pd#(lf)import datetime as dt#(lf)#(lf)Parameters['FromDate'] = pd.to_datetime( Parameters['FromDate'], format=\u0026quot;\u0026quot;%d.%m.%Y\u0026quot;\u0026quot; )#(lf)Parameters['ToDate'] = pd.to_datetime( Parameters['ToDate'], format=\u0026quot;\u0026quot;%d.%m.%Y\u0026quot;\u0026quot; )#(lf)#(lf)Sales = pd.DataFrame( [#(lf) [dt.date(2018,7,1), 10], #(lf) [dt.date(2018,8,1), 20], #(lf) [dt.date(2018,9,1), 30]#(lf) ], columns=['Date', 'Amount' ] #(lf))#(lf)#(lf)Sales['Date'] = pd.to_datetime(Sales['Date'])#(lf)#(lf)Result = Sales[ Sales['Date'] \u0026gt; Parameters['FromDate'][0] ]\u0026quot;,[ Parameters = Parameters ]) in Source    Обратите внимание на то, что все наше красивое форматирование в python Power BI Desktop собрал в одну строку. Так что если далее потребуется дорабатывать наш скрипт мы вернемся в Jupyter и последовательно проделаем шаги: исправим, отладим и так же передадим его через буфер обмена в Power BI Desktop.\n  В результате у нас будет доступны все источники данных в формате DataFrame которые мы объявили в скрипте и далее средствами Power Query как мы привыкли будем обрабатывать таблицы и объединять их в модель.  Материалы Для удобства исследования статьи привожу готовый файл срипта и пример на Power BI:\n Решение на Power BI Файл скрипта на python в формате jupiter Ссылка на интерактивный отчет в Power BI online  Обсуждение решения  Из описания помощи к функции power query Python.Execute видно, что функция получает два параметра function (script as text, optional arguments as nullable record) as table. Обязательный script собственно текст скрипта на Python и не обязательный arguments. Опытным путем понял, что корректным форматом передачи аргументов внутрь скрипта является таблица. Таким образом для передачи аргументов нужно создать запись у которой есть хотя-бы одно значение содержащее таблицу. В нашем случае мы создали запись вида [ Parameters = Parameters ]. Где справа ключ записи, а справа ссылка на таблицу содержащую параметры. При подготовке примера оказалось что у Power BI при передаче параметров есть особенность работы с типом date/datetime. Дату и время в power query нужно приводить к строке. А внутри скрипта на python приводить обратно к типу date/datetime.  ","date":1534723200,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1534723200,"objectID":"6b15c490661b012213b97ebc4ac3584f","permalink":"https://DmitriyVlasov.ru/ru/post/power-bi-use-python-script-with-parameters/","publishdate":"2018-08-20T00:00:00Z","relpermalink":"/ru/post/power-bi-use-python-script-with-parameters/","section":"post","summary":"Предисловие После установки августовского релиза Power BI  я очень обрадовался, увидев поддержку Python. Как раз в работе оказался проект, в котором возможность поддержки Python помогла реализовать требования заказчика. Нужно было подключаться к API, предварительно зашифровывая тело запроса открытым и закрытым ключём, перед отправлением запроса к API. К сожалению, как оказалось, поддержка шифрования в Power BI есть только в кастомных дата коннекторах, и отсутствует в Power Query для Power BI Desktop.","tags":["Power BI","Python"],"title":"Передача Параметров из Power BI в скрипт на Python","type":"post"},{"authors":null,"categories":null,"content":" Прошло почти 3 месяца после моего выступления на митапе яндекс денег по SQL Server. И наконец вышла официальная статья в блоге на хабре. В том числе есть видео запись моего выступления. Атмосфера на митапе и выступлении была теплая и ламповая, сумрак и дружественная атмосфера.\nВо время записи моего выступления, как оказалось позже, \u0026ldquo;что то пошло не так\u0026rdquo; и видео оказалось в масштабе мобильного, расположена в не удобном месте, я в сумраке и экрана с выступлением скорее не видно. Но слышно хорошо, так что можно использовать как запись подкаста.\nP.S.: Послушал сам себя, голос понравился. Но со словами паразитами предстоит еще работать.\nСлайды Это внедренный файл Microsoft Office на платформе Office Online. ","date":1528232400,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1528232400,"objectID":"612efa869dadb6c06b1f5643e91a1093","permalink":"https://DmitriyVlasov.ru/ru/talk/power-bi-and-sql-server-reporting-services/","publishdate":"2018-06-05T21:00:00Z","relpermalink":"/ru/talk/power-bi-and-sql-server-reporting-services/","section":"talk","summary":"Чем отличаются эти две технологии и какое у них будущее? Обсудим особенности каждой, нюансы лицензирования, сравним производительность.","tags":null,"title":"Microsoft PowerBI как альтернатива SQL Server Reporting Services: вместо или вместе?","type":"talk"},{"authors":null,"categories":null,"content":" \nПредисловие Приводится обзор всех существующих функций DAX. Основное назначение статьи максимально возможно упростить обзор и изучение, навигацию и ориентирование по всем существующим функциям DAX в одной статье. По мере появления в статью будут добавляться новые DAX функции.\nСодержание Краткое содержание  Логические функции Текстовые функции Математические и Тригонометрические функции Простые и Интеллектуальные операции с датой и временем Информационные функции Функции Создания и Фильтрации таблиц Статистические функции Функции над Иерархиями Прочие функции Синтаксические элементы  Подробное содержание  Логические функции Текстовые функции  Базовые операции со стоками Форматирование и преобразование типов Поиск и замена  Математические и тригонометрические функции  Базовые операции с числами Округление Операции со случайными числами Тригонометрические функции и константы  Функции даты и времени  Базовые операции с датой и временем Конструкторы даты и времени Расширенные операции с датой  Интеллектуальные операции со временем  Функции возвращающие столбец дат  Операции с периодами Операции днем, месяцем, кварталом и годом  Функции возвращающие ячейку с датой Функции возвращающие ячейку со значением Функции возвращающие скалярное значение  Информационные функции  Информация о пользжователе Обработка ошибок  Функции фильтрации Агрегатные и статистические функции  Агрегатные функции над таблицами Агрегатные функции над столбцами и выражениями Статистические функции над столбцами и выражениями Замечания к агрегатным и статистическим функциям  Функции над иерархическими данными Прочие функции Синтаксические элементы  \nЛогические функции    Имя функции Описание     TRUE Возвращает логическое значение true.   FALSE Возвращает логическое значение false.   AND Проверяет значения аргументов и возвращает значение true, если оба аргумента имеют значение true. В противном случае возвращает значение false.   OR Проверяет, является ли один из аргументов true, и если да, то возвращает значение true. Функция возвращает значение false, если оба аргумента имеют значение false.   NOT Изменяет значение false на true, а true на false.   IF Проверяет выполнение условия, указанного в первом аргументе. Возвращает одно значение, если условие равно true, и другое значение, если условие равно false.   SWITCH Вычисляет выражение на основе списка значений и возвращает одно из нескольких возможных результирующих выражений.    К содержанию\n\nТекстовые функции Текстовые функции, основаны на библиотеке строковых функций в Excel. C помощью этих функций можно вернуть часть строки, искать текст в строке или объединить строковые значения, а так же для управления форматами дат, времени и чисел.\n\nБазовые операции со стоками    Имя функции Описание     CONCATENATE Соединяет две текстовые строки в одну текстовую строку (Чаще удобнее использовать оператор \u0026amp;).   CONCATENATEX Функция работает над таблицей и возвращает текстовую строку. Сначала для каждой записи таблицы вычисляет выражение, а затем сводит все вычесленные записи таблицы в одну строку с учетом разделителя из параметров.   REPT Повторяет текст заданное количество раз.   LEFT Возвращает указанное количество символов с начала текстовой строки.   RIGHT Функция RIGHT возвращает последний символ или последние символы текстовой строки, в зависимости от указанного количества символов.   TRIM Удаляет все пробелы из текста, за исключением единичных пробелов между словами.   LOWER Преобразует все буквы в текстовой строке в нижний регистр.   UPPER Преобразует все буквы в текстовой строке в верхний регистр.    \nФорматирование и преобразование типов    Имя функции Описание     FORMAT Преобразует значение в текст в указанном числовом формате. (см. также предопределенные форматы чисел и даты и времени. Пользовательские форматы чисел и даты и времени)   FIXED Преобразует значение в текст в указанном числовом формате.   VALUE Преобразует текстовую строку, представляющую число, в число.   CURRENCY Вычисляет аргумент и возвращает результат как тип данных currency.    \nПоиск и замена    Имя функции Описание     UNICHAR Возвращает символ Юникод по его числовому значению. Работает аналогично функции Excel ЮНИСИМВ   UNICODE Возвращает число (код знака), соответствующее первому знаку в тексте.   LEN Возвращает число символов в текстовой строке.   SEARCH Возвращает номер позиции, начиная с которой обнаружена подстрока. Поиск идет слева на право без учета регистра и с учетом диакритических знаков.   FIND Возвращает начальный номер позиции, начиная с которой обнаружена подстрока. Поиск идет с учетом регистра.   MID Возвращает строку символов из середины текстовой строки с учетом начальной позиции и длины.   REPLACE Заменяет часть текстовой строки другой текстовой строкой на основе указанного числа символов.   SUBSTITUTE Заменяет существующий текст новым в текстовой строке.   EXACT Сравнивает две текстовые строки и возвращает true, если они полностью одинаковые, и false в противном случае. Функция учитывает регистр, но не учитывает отличия форматирования. Можно использовать функцию, чтобы проверить входящий в документ текст.    К содержанию\n\nМатематические и тригонометрические функции Математические функции в DAX похожи на математические и тригонометрические функции Excel. Однако имеются некоторые отличия в типах числовых данных.\n\nБазовые операции с числами    Имя функции Описание     SQRT Возвращает квадратный корень числа.   POWER Возвращает результат возведения числа в степень.   SIGN Определяет знак числа, результата вычисления или значения в столбце. Функция возвращает значение 1, если число положительное, значение 0 (ноль), если число равно нулю, и значение -1, если число отрицательное.   QUOTIENT Выполняет деление и возвращает только целочисленную часть результата. Эта функция используется, если не нужно учитывать остаток от деления.    \nОкругление    Имя функции Описание     ABS Возвращает абсолютное значение числа.   INT Округляет число в меньшую сторону до ближайшего целого.   ROUND Округляет число до указанного количества разрядов.   ROUNDDOWN Округляет число вниз, к нулю.   ROUNDUP Округляет число в большую сторону, от 0 (нуля).   FLOOR Округляет число в меньшую сторону (к нулю) до ближайшего числа, кратного заданной значимости.   CEILING Округляет число в большую сторону до ближайшего целого или до ближайшего числа, кратного заданной значимости.   ISO.CEILING Округляет число в большую сторону до ближайшего целого или до ближайшего числа, кратного заданной значимости.   MROUND Возвращает число, округленное до кратного заданной значимости.   TRUNC Усекает число до целого, удаляя дробную часть.    \nОперации со случайными числами    Имя функции Описание     RAND Возвращает случайное число, большее или равное 0 и меньшее 1, с равномерным распределением. Возвращаемое число изменяется каждый раз при пересчете ячейки, содержащей данную функцию.   RANDBETWEEN Возвращает случайное число, расположенное в интервале между двумя заданными числами.    \nТригонометрические функции и константы    Имя функции Описание     PI Возвращает число $Pi$ с точностью до 15 знака.   LOG Возвращает логарифм числа по указанному основанию.   LOG10 Возвращает логарифм числа по основанию 10.   LN Возвращает натуральный логарифм числа. Натуральные логарифмы вычисляются по основанию $e$.   EXP Возвращает значение выражения $e^n$, где $n$ - заданное в параметрах число. Функция EXP обратна функции LN.   FACT Возвращает факториал числа.    К содержанию\n\nФункции даты и времени Многие функции даты и времени в DAX схожи с функциями даты и времени Excel. Однако в функциях DAX используется тип данных datetime Microsoft SQL Server.\n\nБазовые операции с датой и временем    Имя функции Описание     YEAR Возвращает для заданной даты год в виде четырехзначного числа от 1900 до 9999.   MONTH Возвращает месяц в виде числа от 1 до 12.   DAY Возвращает день месяца в виде числа от 1 до 31.   HOUR Возвращает значение часа в виде числа от 0 до 23.   MINUTE Возвращает число минут от 0 до 59 по заданному значению даты и времени.   SECOND Возвращает для заданного значения времени число секунд в виде числа от 0 до 59.   WEEKDAY Возвращает число от 1 до 7, определяющее день недели для даты. По умолчанию дни недели считаются от воскресенья (1) до субботы (7).   WEEKNUM Возвращает номер недели для заданных даты и года в соответствии со значением тип возврата. Номер недели указывает числовую позицию недели относительно начала года.    \nКонструкторы даты и времени    Имя функции Описание     DATE Преобразует год, месяц, день, заданный в виде чисел в дату формате datetime.   TIME Преобразует часы, минуты и секунды, заданные в виде чисел, во время в формате datetime.   DATEVALUE Преобразует дату из текстового формата в дату в формате datetime.   TIMEVALUE Преобразует время из текстового формата во время в формате datetime.   TODAY Возвращает текущую дату без времени.   NOW Возвращает текущую дату и время.    \nРасширенные операции с датой    Имя функции Описание     DATEDIFF Возвращает интервал времени между двумя датами. (Тип интервала указывается в параметре Interval) Интервал может принимать следующие значения: second, minute, hour, day, week, month, quarter, year.   YEARFRAC Вычисляет долю года, представленную числом целых дней между двумя датами. Функция позволяет определить долю преимуществ или обязательств за целый год, приходящуюся на указанный срок.   EDATE Возвращает дату, отстоящую от заданной даты на указанное число месяцев (до или после). С помощью функции вычисляются сроки обязательств и платежей, приходящиеся на тот же день месяца, что и начало расчетного периода.   EOMONTH Возвращает дату окончания месяца (до или после указанного числа месяцев). С помощью функции вычисляются сроки обязательств и платежей, приходящиеся на конец месяца.    К содержанию\n\nИнтеллектуальные операции со временем Интеллектуальные операции со временем, поддерживают методы анализа бизнес-аналитики и позволяют работать с данными с использованием временных периодов, таких как дни, месяцы, кварталы и годы.\nЭти функции позволяют выполнять вычисления с использованием встроенных наборов знаний о календарях и датах.\nИспользуя диапазоны времени и дат вместе со статистическими выражениями можно создавать осмысленные сравнения по сравнимым периодам времени для продаж, количеству товара и так далее.\n\nФункции возвращающие столбец дат Столбец дат это таблица содержащую один столбец со значениями даты.\n\nОперации с периодами    Имя функции Описание     DATEADD Столбец дат, сдвинутых в будущее или в прошлое от дат в текущем контексте на указанное количество интервалов.   DATESBETWEEN Столбец дат, за период с начальной до конечной даты.   DATESINPERIOD Столбец дат, который начинается с начальной даты и продолжается определенное количество интервалов.   PARALLELPERIOD Столбец дат, со сдвинутыми на несколько интервалов вперед или назад датами, от дат из столбца параметров в текущем контексте.   SAMEPERIODLASTYEAR Столбец дат, со сдвинутыми на один год назад от дат, из столбца параметров в текущем контексте.    \nОперации днем, месяцем, кварталом и годом    Тип День Месяц Квартал Год     Текущий - DATESMTD DATESQTD DATESYTD   Предыдущий PREVIOUSDAY PREVIOUSMONTH PREVIOUSQUARTER PREVIOUSYEAR   Следующий NEXTDAY NEXTMONTH NEXTQUARTER NEXTYEAR    \nФункции возвращающие ячейку с датой Ячейка это таблица с одним столбцом и одной строкой.\n   Тип День Месяц Квартал Год     Первый FIRSTDATE STARTOFMONTH STARTOFQUARTER STARTOFYEAR   Последний LASTDATE ENDOFMONTH ENDOFQUARTER ENDOFYEAR    \nФункции возвращающие ячейку со значением Ячейка это таблица с одним столбцом и одной строкой.\n   Имя функции Описание     FIRSTNONBLANK Возвращает первое значение в столбце column (с фильтрацией по текущему контексту), где выражение не является пустым.   LASTNONBLANK Возвращает последнее значение в столбце column (с фильтрацией по текущему контексту), где выражение не является пустым.    \nФункции возвращающие скалярное значение    Тип Месяц Квартал Год     Сальдо на начало OPENINGBALANCEMONTH OPENINGBALANCEQUARTER OPENINGBALANCEYEAR   Оборот TOTALMTD TOTALQTD TOTALYTD   Сальдо на конец CLOSINGBALANCEMONTH CLOSINGBALANCEQUARTER CLOSINGBALANCEYEAR    К содержанию\n\nИнформационные функции Информационная функция проверяет ячейку или строку, указанные в качестве аргумента, и сообщает, соответствует ли значение ожидаемому типу.\n   Имя функции Описание     ISBLANK Проверяет, пустое ли значение, и возвращает значение true или false.   ISEMPTY Возвращает значение true, если таблица пустая.   ISLOGICAL Проверяет, является ли значение ошибкой, и возвращает true или false.   ISTEXT Проверяет, является ли значение текстом, и возвращает true или false.   ISNONTEXT Проверяет, не является ли значение текстом (пустые ячейки не являются текстом), и возвращает true или false.   ISNUMBER Проверяет, является ли значение числом, и возвращает true или false.   ISEVEN Возвращает значение ИСТИНА, если число четное, и значение ЛОЖЬ, если нечетное.   ISODD Возвращает значение ИСТИНА, если число нечетное, и значение ЛОЖЬ, если четное.   ISFILTERED Возвращает значение true, если columnName фильтруется напрямую. Если для столбца не задан фильтр или если фильтрация происходит потому, что выполняется фильтрация другого столбца в той же или в связанной таблице, функция возвращает значение false.   ISCROSSFILTERED Возвращает значение true при фильтрации по столбцу columnName или другому столбцу в этой же или связанной таблице.   [ISSUBTOTAL]() Возвращает значение true, если текущая строка содержит подытог для заданного столбца, в противном случае возвращает false.   ISONORAFTER Логическая функция, которая эмулирует поведение предложения Start At и возвращает true для строки, которая соответствует всем параметрам условия. Эта функция принимает переменное число аргументов кратное трем (т.н. троек), первые два аргумента в тройке - это сравниваемые выражения, а третий аргумент указывает порядок сортировки. Порядок сортировки по увеличению (по умолчанию) или уменьшению.   CONTAINS Возвращает значение true, если значения для всех столбцов, на которые имеются ссылки, существуют или содержатся в этих столбцах; в противном случае возвращает значение false.   CONTAINSROW Возвращает значение true, если существует по меньшей мере одна строка, в которой все столбцы имеют указанные значения.   HASONEFILTER Возвращает значение true, если число значений, отсортированных по columnName, равно одному; в противном случае возвращает значение false.   HASONEVALUE Возвращает значение true при фильтрации содержимого столбца columnName до одного уникального значения. В противном случае возвращается значение false.    \nИнформация о пользователе    Имя функции Описание     USERNAME Возвращает имя домена и имя пользователя из учетных данных, предоставленных системе при подключении.   [USEROBJECTID]() Возвращает идентификатор объекта текущего пользователя из Azure AD для сервера анализа данных Azure и идентификатор безопасности текущего пользователя для локального сервера анализа данных.   [USERPRINCIPALNAME]() Возвращает имя субъекта-пользователя.    \nОбработка ошибок    Имя функции Описание     ERROR Принимает текстовое сообщение и порождает ошибку. Может использовать в формулах для описания недопустимого состояния пользовательских данных.   ISERROR Проверяет, является ли значение ошибкой, и возвращает true или false.   IFERROR Вычисляет выражение и возвращает указанное значение, если выражение ошибочно. В противном случае возвращает значение выражения.    К содержанию\n\nФункции фильтрации Функции фильтра и значений DAX относятся к самым мощным и сложным, значительно отличаясь от функций Excel. Функции поиска работают с использованием таблиц и связей, как в базе данных. Функции фильтрации дают возможность управлять контекстом данных для создания динамических вычислений. Описание контекста см. в разделе Контекст в формулах DAX.\n   Имя функции Описание     LOOKUPVALUE Возвращает значение в столбце result_columnName для строки, соответствующей всем критериям, указанным с помощью параметров search_columnName и search_value.   CALCULATE Вычисляет выражение в контексте, изменяемом указанными фильтрами.   CALCULATETABLE Вычисляет табличное выражение в контексте, изменяемом данными фильтрами.   RELATED Возвращает связанное значение из другой таблицы.   RELATEDTABLE Вычисляет табличное выражение в контексте, изменяемом данными фильтрами.   ALL Возвращает все строки в таблице или все значения в столбце, не учитывая применяемые фильтры. Эта функция полезна для очистки фильтров и создания вычислений по всем строкам таблицы.   ALLEXCEPT Удаляет все фильтры контекста в таблице, кроме фильтров, примененных к указанным столбцам.   ALLNOBLANKROW Из родительской таблицы связи возвращает все непустые строки либо все различные значения столбца, за исключением пустых строк, не учитывая существующие фильтры контекста.   ALLSELECTED Удаляет фильтры содержимого из столбцов и строк в текущем запросе, сохраняя все остальные фильтры содержимого и явные фильтры. Функция ALLSELECTED возвращает содержимое, представляющее все строки и столбцы в запросе, сохраняя явные фильтры и фильтры содержимого, не относящиеся к фильтрам строк и столбцов. Эту функцию можно использовать для получения визуальных итогов в запросах.   FILTER Возвращает таблицу, представляющую подмножество другой таблицы или выражения.   FILTERS Возвращает значения, которые напрямую применяются в качестве фильтров к столбцу columnName.   DISTINCT Возвращает таблицу из одного столбца, содержащую уникальные значения из указанного столбца. Другими словами, повторяющиеся значения удаляются, и возвращаются только уникальные значения. Примечание Эту функцию нельзя использовать для возвращения результатов в ячейку или столбец на листе. Функция DISTINCT вкладывается в формулу, чтобы получить список уникальных значений, который можно передать другой функции, а затем выполнить подсчет, суммирование или другие операции.   VALUES Возвращает таблицу с одним столбцом, содержащую уникальные значения из указанного столбца или таблицы. Другими словами, повторяющиеся значения удаляются, и возвращаются только уникальные значения. Примечание Эту функцию нельзя использовать для возвращения результатов в ячейку или столбец на листе. Она служит в качестве промежуточной функции, вложенной в формулу, чтобы получить список уникальных значений, которые можно подсчитать или использовать для фильтрации или суммирования других значений.   EARLIER Возвращает текущее значение указанного столбца на внешнем этапе вычисления для данного столбца. Функция EARLIER полезна для вложенных вычислений, когда необходимо указать в качестве входного определенное значение и в зависимости от него проводить вычисления. В Microsoft Excel такие вычисления можно выполнять только в контексте текущей строки, однако в DAX можно сохранить входное значение, а затем выполнить вычисление с использованием данных из всей таблицы. Функция EARLIER используется главным образом в контексте вычисляемых столбцов.   EARLIEST Возвращает текущее значение указанного столбца на внешнем этапе вычисления для данного столбца.   CUSTOMDATA Возвращает содержимое свойства CustomData в строке подключения.    К содержанию\n\nАгрегатные и статистические функции Язык выражений анализа данных предоставляет множество функций для вычисления агрегированных выражений. Эти функции:\n Схожи со статистическими функциями, используемыми в Microsoft Excel. Выполняют статистические выражения. Позволяют отфильтровать столбец, прежде чем выполнять статистическую обработку или создавать статистические выражения на основе связанных таблиц.  \nАгрегатные функции над таблицами    Имя функции Описание     ADDCOLUMNS Добавляет вычисляемые столбцы к выбранной таблице или табличному выражению.   COUNTROWS Возвращает количество строк в таблице.   ROW Возвращает однострочную таблицу. Эта таблица содержит значения, являющиеся результатом выражения, заданного для каждого столбца.   TOPN Возвращает первые $N$ строк таблицы.   SUMMARIZE Возвращает сводную таблицу с вычисленными итогами для перечня сгруппированных столбцов.   SUMMARIZECOLUMNS Возвращает таблицу-сводку по набору групп.   GROUPBY Функция GROUPBY аналогична функции SUMMARIZE. Однако GROUPBY не выполняет неявный CALCULATE для любых добавочных столбцов, которые он добавляет. GROUPBY разрешает использовать новую функцию CURRENTGROUP() внутри функций агрегации в добавочных столбцах, которые она добавляет. GROUPBY пытается повторно использовать данные, которые были сгруппированы, что делает его высокоэффективным.   CROSSJOIN Возвращает декартово произведение $1 + N$ таблиц, где $N \u0026gt;= 1$.   GENERATE Возвращает декартово произведение всех строк в таблице 1 и таблицы, являющейся результатом вычисления таблицы 2 в контексте текущей строки из таблицы 1.   GENERATEALL Аналогично GENERATE.   INTERSECT Возвращает пересечение строк двух таблиц, сохраняя дубликаты.   NATURALINNERJOIN Выполняет внутреннее соединение таблицы с другой таблицей. Таблицы объединены в общие столбцы (по имени) в двух таблицах. Если две таблицы не имеют общих имен столбцов, возвращается ошибка.   NATURALLEFTOUTERJOIN Выполняет внутреннее соединение таблицы с другой таблицей. Таблицы объединены в общие столбцы (по имени) в двух таблицах. Если две таблицы не имеют общих имен столбцов, возвращается ошибка.   UNION Создает таблицу объединения (объединения) из пары таблиц.   EXCEPT Возвращает строки одной таблицы, которых не существует в другой таблице.   DATATABLE Создает таблицу с константными значениями средствами языка DAX. Полезно для использования в случае создания короткого редко изменчивого справочника на уровне DAX.    \nАгрегатные функции над столбцами и выражениями    Описание Обычные1 Тип A2 Тип X3 Тип AX4     Сумма SUM - SUMX -   Среднее AVERAGE AVERAGEA AVERAGEX -   Минимум MIN MINA MINX -   Максимум MAX MAXA MAXX -   Количество значений COUNT COUNTA COUNTX COUNTAX   Количество пустых значений COUNTBLANK - - -   Количество разных значений DISTINCTCOUNT - - -    \nСтатистические функции над столбцами и выражениями    Описание Обычные1 Тип X3     Ранг RANK.EQ RANKX   Дисперсия всей совокупности VAR.P VARX.P   Дисперсия выборки VAR.S VARX.S   Стандартное отклонение всей совокупности STDEV.P STDEVX.P   Стандартное отклонение выборки STDEV.S STDEVX.S    \nЗамечания к агрегатным и статистическим функциям  Обычные  - Позволяет вычислить функцию над столбцом. Принимает только числовые значения. Не производит преобразование данных из других типов данных в число, если ячейка содержит:  текст - функция не вычисляется и возвращает пусто; логическое значение - ячейка игнорируется. пустое значение - ячейка игнорируется. нулевое значение - ячейка учитывается в расчете.  Тип A  - Позволяет вычислить функцию над столбцом. Производит преобразование данных других типов к числу (в отличии от обычных функций). Если ячейка содержит:  текст - если возможно производится преобразование к числу, иначе логическое значение - истина = 1, ложь = 0; возвращается; пустое значение - ячейка игнорируется. нулевое значение - ячейка учитывается в расчете.  Тип X  - Позволяет вычислить функцию над выражением, а не над столбцом отличии от обычных функций и функций типа A. В принципе обработки не числовых значений аналогичная обычной функции. Тип AX  - Позволяет вычислить функцию над выражением, а не над столбцом отличии от обычных функций и функций типа A. В принципе обработки не числовых значений аналогичная функциям типа A.  К содержанию\n\nФункции над иерархическими данными Функции для управления данными, представленными в моделях в виде иерархии типа «родители-потомки». Эти функции можно использовать для получения следующих данных:\n Общее количество родительских элементов строки, количество уровней в иерархии до родительского элемента верхнего уровня, Идентификатор родительского элемента, расположенного на n уровней выше текущей строки, Идентификатор n-потомка, считая от верхнего уровня иерархии. Определить, является ли определенный родительский элемент элементом иерархии текущей строки. (см. подробнее)     Имя функции Описание     PATH Возвращает строку текста с разделителями, содержащую идентификаторы всех родительских элементов текущего идентификатора, с самого старого до текущего.   PATHLENGTH Возвращает количество родительских элементов указанного элемента в заданных результатах функции PATH, включая сам элемент.   PATHCONTAINS Возвращает значение true, если указанный объект item существует в указанном объекте path.   PATHITEM Возвращает элемент с указанным параметром position из строки результатов вычисления функции PATH. Позиции считаются слева направо.   PATHITEMREVERSE Возвращает элемент с указанным параметром position из строки результатов вычисления функции PATH. Позиции вычисляются в направлении справа налево.    К содержанию\n\nПрочие функции эти функции выполняют уникальные действия, которые не могут быть определены ни одной из других категорий, к которым принадлежит большинство функций.\n   Имя функции Описание     BLANK Возвращает пустое значение.    К содержанию\n\nСинтаксические элементы Несмотря на то что DAX является библиотекой функций ее эволюционное развитие привело разработчиков к необходимости введения удобных синтаксических элементов характерных для языков программирования.\nНапример выражение VAR ... RETURN успешно используется для уменьшения сложности написания и чтения DAX функций с помощью построения промежуточных вычислений. А типы данных используются при построении справочника на уровне DAX с помощью функции DATATABLE.\n   Имя элемента Описание     VAR Сохраняет результат выражения как именованную переменную, которая затем может быть передана как аргумент другим выражениям. Когда результирующие значения были рассчитаны для выражения переменных, эти значения не изменяются, даже если эта переменная указана в другом выражении.   IN Возвращает значение true, если существует по меньшей мере одно значение, в которой все столбцы имеют указанные значения.   RETURN Возвращает результат вычисления формулы используется совместно с выражением VAR.   INTEGER Целое число   DOUBLE Число с плавающей точкой   STRING Строка   BOOLEAN Логическая переменная   CURRENCY Валюта   DATETIME Дата время    К содержанию\n","date":1500459091,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1500459091,"objectID":"5b15fe217d6bb3f38db8a3de66fe1ad0","permalink":"https://DmitriyVlasov.ru/ru/post/dax-functions/","publishdate":"2017-07-19T13:11:31+03:00","relpermalink":"/ru/post/dax-functions/","section":"post","summary":"Предисловие Приводится обзор всех существующих функций DAX. Основное назначение статьи максимально возможно упростить обзор и изучение, навигацию и ориентирование по всем существующим функциям DAX в одной статье. По мере появления в статью будут добавляться новые DAX функции.\nСодержание Краткое содержание  Логические функции Текстовые функции Математические и Тригонометрические функции Простые и Интеллектуальные операции с датой и временем Информационные функции Функции Создания и Фильтрации таблиц Статистические функции Функции над Иерархиями Прочие функции Синтаксические элементы  Подробное содержание  Логические функции Текстовые функции  Базовые операции со стоками Форматирование и преобразование типов Поиск и замена  Математические и тригонометрические функции  Базовые операции с числами Округление Операции со случайными числами Тригонометрические функции и константы  Функции даты и времени  Базовые операции с датой и временем Конструкторы даты и времени Расширенные операции с датой  Интеллектуальные операции со временем  Функции возвращающие столбец дат  Операции с периодами Операции днем, месяцем, кварталом и годом  Функции возвращающие ячейку с датой Функции возвращающие ячейку со значением Функции возвращающие скалярное значение  Информационные функции  Информация о пользжователе Обработка ошибок  Функции фильтрации Агрегатные и статистические функции  Агрегатные функции над таблицами Агрегатные функции над столбцами и выражениями Статистические функции над столбцами и выражениями Замечания к агрегатным и статистическим функциям  Функции над иерархическими данными Прочие функции Синтаксические элементы","tags":["Power BI","DAX","Обзор"],"title":"Обзор всех функций DAX","type":"post"},{"authors":null,"categories":null,"content":" Пустое значение в:\n SQL это null; Excel это не заполненная ячейка; DAX это blank.  В DAX также существует функция blank() возвращающее пустое значение.\nТаблица сравнения поведения пустого значения в разных окружениях\n   Выражение DAX Excel SQL1     blank + blank blank 0 (ноль) blank   blank + 5 5 5 blank   blank * 5 blank 0 (ноль) blank   5 / blank infinity error blank   0 / blank nan error blank   blank / blank blank error blank   false or blank false false -   false and blank false false -   true or blank true true -   true and blank false true -   blank or blank blank error -   blank and blank blank error -    Источники  docs.microsoft.com, Handling of Blanks, Empty Strings, and Zero Values MSDN, Функция BLANK   В SQL Server отсутствует логический тип данных. Поэтому в явном виде логические операции и таблицы истинности в SQL не применимы. Хотя в предложении WHERE и есть выражения or или and Которые позволяют объединять между выражения возвращающие логический контекст. ^   ","date":1499259385,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1499259385,"objectID":"86230eb831fdd863ff64104073954cc6","permalink":"https://DmitriyVlasov.ru/ru/post/handing-of-dax-blank/","publishdate":"2017-07-05T15:56:25+03:00","relpermalink":"/ru/post/handing-of-dax-blank/","section":"post","summary":"Пустое значение в:\n SQL это null; Excel это не заполненная ячейка; DAX это blank.  В DAX также существует функция blank() возвращающее пустое значение.\nТаблица сравнения поведения пустого значения в разных окружениях\n   Выражение DAX Excel SQL1     blank + blank blank 0 (ноль) blank   blank + 5 5 5 blank   blank * 5 blank 0 (ноль) blank   5 / blank infinity error blank   0 / blank nan error blank   blank / blank blank error blank   false or blank false false -   false and blank false false -   true or blank true true -   true and blank false true -   blank or blank blank error -   blank and blank blank error -    Источники  docs.","tags":["Power BI","Excel","Tabular","SQL Server","DAX","SQL"],"title":"Сравнение обработки пустых значений в DAX, Excel и SQL","type":"post"},{"authors":null,"categories":null,"content":" Синтаксис EARLIER(column, [number])  Параметры    Параметр Обязательный Описание     column Да Столбец или выражение, результатом которого служит столбец.   number Нет Следующий внешний этап вычисления. По умолчанию 1.    Возвращаемое значение Текущее значение строки из столбца column на расстоянии в number внешних этапов вычисления.\nПример = COUNTROWS ( FILTER ( ProductSubcategory; EARLIER ( ProductSubcategory[TotalSubcategorySales] ) \u0026lt; ProductSubcategory[TotalSubcategorySales] ) ) + 1   Функция EARLIER получает значение TotalSubcategorySales для текущей строки в таблице. В данном случае, поскольку процесс только начинается, это первая строка в таблице. EARLIER([TotalSubcategorySales]) дает результат $ 156 176.88 — текущая строка во внешнем цикле. Теперь функция FILTER возвращает таблицу, где все строки имеют значение TotalSubcategorySales, превышающее $ 156 176.88 (текущее значение EARLIER). Функция COUNTROWS подсчитывает строки отфильтрованной таблицы и присваивает новому вычисляемому столбцу в текущей строке полученное значение и прибавляет единицу 1. Формула вычисляемого столбца переходит к следующей строке, и шаги с 1 по 4 повторяются. Эти шаги повторяются до конца таблицы. Функция EARLIER всегда получает значение столбца перед выполнением текущей операции в таблице. Чтобы получить значение на более раннем этапе цикла, установите второй аргумент в значение 2.   Прибавлять единицу необходимо, чтобы предотвратить появление пустого значения в качестве значения с верхним рангом. ^   ","date":1499243825,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1499243825,"objectID":"0800f30bb7cbb4eab3f9cfd7b12c9461","permalink":"https://DmitriyVlasov.ru/ru/post/dax-function-earlier/","publishdate":"2017-07-05T11:37:05+03:00","relpermalink":"/ru/post/dax-function-earlier/","section":"post","summary":"Синтаксис EARLIER(column, [number])  Параметры    Параметр Обязательный Описание     column Да Столбец или выражение, результатом которого служит столбец.   number Нет Следующий внешний этап вычисления. По умолчанию 1.    Возвращаемое значение Текущее значение строки из столбца column на расстоянии в number внешних этапов вычисления.\nПример = COUNTROWS ( FILTER ( ProductSubcategory; EARLIER ( ProductSubcategory[TotalSubcategorySales] ) \u0026lt; ProductSubcategory[TotalSubcategorySales] ) ) + 1   Функция EARLIER получает значение TotalSubcategorySales для текущей строки в таблице.","tags":["Power BI","Excel","DAX"],"title":"Пример использования функции EARLIER","type":"post"},{"authors":null,"categories":null,"content":" 1 июня 2017 принял участие в мероприятии DevCon School Технологии будущего проводимого компанией Microsoft. Мероприятие проходило в Москве на территории центра Digital October. Ключевыми темами мероприятия были: Искусственный интеллект, Блокчейн, Azure Stack и гибридные облака, контейнеры и микросервисы, DevOps и процессы разработки, Безопасная разработка, Машинное обучение. Подборка ссылок на материалы  Запись видео с открытия, интенсива по нейронным сетям и отдельным трекам Презентации и обучающие материалы с интенсива и большинства треков  Машинное обучение  Определение опечаток в тексте Алгоритм расстояние Левенштейна Метод обратного распространения ошибки Как выбрать компьютер для машинного обучения\n NVidia Deep Learning Institute. Практические материалы и учебные курсы по глубокому обучению:\n Глобальный портал Российская локализация   Сообщества  Официальный русскоязычный канал в телеграмме Microsoft Developer Официальный канал Microsoft в телеграмме по машинному обучению и интеллектуальным сервисам Обучение Если вас заинтересовали прикладные вопросы Машинного обучения и анализа данных рекомендую начать изучение вопроса с блога Ильи Шутова на хабре\n Для комплексного обучения по направлению машинное обучение и анализ данных рекомендую специализацию Машинное обучение и анализ данных от МФТИ и Яндекса\n  ","date":1497052800,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1497052800,"objectID":"3fc8a9b009bf8f810bb8712b1b79674b","permalink":"https://DmitriyVlasov.ru/ru/post/devcon-school-future-technologies/","publishdate":"2017-06-10T00:00:00Z","relpermalink":"/ru/post/devcon-school-future-technologies/","section":"post","summary":"1 июня 2017 принял участие в мероприятии DevCon School Технологии будущего проводимого компанией Microsoft. Мероприятие проходило в Москве на территории центра Digital October. Ключевыми темами мероприятия были: Искусственный интеллект, Блокчейн, Azure Stack и гибридные облака, контейнеры и микросервисы, DevOps и процессы разработки, Безопасная разработка, Машинное обучение. Подборка ссылок на материалы  Запись видео с открытия, интенсива по нейронным сетям и отдельным трекам Презентации и обучающие материалы с интенсива и большинства треков  Машинное обучение  Определение опечаток в тексте Алгоритм расстояние Левенштейна Метод обратного распространения ошибки Как выбрать компьютер для машинного обучения","tags":["Microsoft","DevCon","Школа","Конференция","Заметка"],"title":"Заметки с мероприятия Технологии будущего. Microsoft Devcon School","type":"post"},{"authors":["Стефан Тольксдорф","Дмитрий Власов"],"categories":null,"content":" Введение Этот учебник знакомит вас с основными понятиями библиотеки FParsec. Наша цель \u0026mdash; дать вам возможность попробовать создать приложения синтаксического разбора с помощью библиотеки FParsec. Мы охватим только основные идеи и дадим беглый обзор библиотеки по APIen. Но, надеемся, это будет достаточной основой для того, чтобы вы могли в дальнейшем использовать FParsec самостоятельно с помощью: руководства пользователяen, справочника по APIen и примеров синтаксических анализаторов в папке Samplesen.\nБлагодарности Благодарю мою жену Ольгу за помощь в переводе, стилистической выверке и редактуре теста.\nОглавление  Вступление Синтаксический анализатор числа с плавающей точкой Синтаксический анализатор числа с плавающей точкой в скобках Абстрактные синтаксические анализаторы Синтаксический анализатор списка чисел с плавающей точкой Обработка пробелов Синтаксический анализатор строковых данных Использование последовательности синтаксических анализаторов Использование альтернативных синтаксических анализов Ограничение значений F# Синтаксический анализ JSON (В работе) Куда дальше? (В работе)  Учебник на других языках  Стефан Тольксдорф, авторский текст на английском языке. Gab_km, перевод на японский язык.   ","date":1485561600,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1485561600,"objectID":"f1e943c9f27a57f9264842f18937cd3f","permalink":"https://DmitriyVlasov.ru/ru/publication/fparsec-tutorial/fparsec-tutorial/","publishdate":"2017-01-28T00:00:00Z","relpermalink":"/ru/publication/fparsec-tutorial/fparsec-tutorial/","section":"publication","summary":"Этот учебник знакомит вас с основными понятиями библиотеки FParsec. Цель этого учебника это дать вам возможность попробовать создать приложения синтаксического разбора с помощью библиотеки FParsec. Что будет достаточной основой для того, чтобы вы могли в дальнейшем использовать FParsec самостоятельно с помощью руководства пользователя, справочника по API и примеров синтаксических анализаторов.","tags":null,"title":"Учебник библиотеки FParsec","type":"publication"},{"authors":null,"categories":null,"content":" В своей работы при поддержке информационных систем зачастую кроме предлагаемых основной платформой средств приходиться использовать еще ряд дополнительных инструментов и сервисов.\nНиже описан используемый мною \u0026ldquo;чемоданчик инструментов\u0026rdquo;.\nЧасть инструментов вы сами можете использовать уже сегодня и возможно использовали раньше. Часть инструментов может быть для вас новой. Все приведенные ниже инструменты использовались мною в работе на ежедневной основе (F#). По части инструментов были пилотные и экспериментальные проекты, но которые считаю очень перспективными и на которые, по моему мнению, стоит обратить внимание при развитии ИТ среды предприятия (язык R, язык PowerShell, Microsoft Power BI).\nЧасть это утилиты, которые мы можете использовать здесь и сейчас, часть требует вдумчивого обучения (в первую очередь это касается языков программирования) но затем возвращается сторицей. Приведенные ссылки позволяют вам стартовать с этими инструментами уже сегодня. За ссылки из этого списка я бы много отдал бы ранее.\nБольшинство предлагаемых ресурсов находятся в отрытом доступе и не требуют дополнительной платы для использования на работы и дома. Программные продукты, кроме расширений Майрософт Офис имеют открытый исходный код. Сервисы бесплатные и не требуют платы за использование. Если сервис или программа требует оплаты об этом описано отдельно.\nУтилиты  Greenshot \u0026mdash; Создание скриншотов, и обработка снимков KeePass \u0026mdash; Безопасное хранение паролей Notepad++ \u0026mdash; Продвинутый текстовый редактор с поддержкой поиска по файловой системе и регулярными выражениями OBS Studio \u0026mdash; Запись видео с экрана или звука из скайпа или «софтофона» Cisco. SQL Dynamite \u0026mdash; Поиск метаданных в любых реляционных базах данных в частности в SQL Server. Visual Studio Code \u0026mdash; Современный расширяемый текстовый редактор. С богатым набором расширений. VLC \u0026mdash; Известный видео комбайн с отличной функцией ускоренной перемотки. Позволяет просматривать видео на удобной вас скорости с ускорением до четырех и более раз. WinDirStat \u0026mdash; Статистика использования файловой системы. WinMerge \u0026mdash; Утилита сравнения версий исходного кода. Git \u0026mdash; Система вершинного хранения чего угодно. ScreenToGif \u0026mdash; Программа для создания анимированных гифок для использования в интерактивных инструкциях. Sqlitebrowser \u0026mdash; Программа просмотра структуры и данных встраиваемой базы данных SQLLite. (Используется повсеместно, в практике БТК используется 1С ERP для хранения логов операций.) StatiCal SQL Server Management Studio (SSMS)  Майкрософт Офис  Onenote \u0026mdash; программа для создания быстрых заметок и организации личной информации, блокнот с иерархической организацией записей, может служить аналогом обычного канцелярского блокнота. Использовал для систематизации знаний и поддержки ИТ систем. Power Query \u0026mdash; это технология подключения данных, которое дает возможность находить, подключение, объединения и уточнения источников данных в соответствии с потребностями анализа.  Языки программирования  F# \u0026mdash; это мультипарадигмальный язык программирования из семейства языков .NET Framework, поддерживающий функциональное программирование в дополнение к императивному (процедурному) и объектно-ориентированному программированию. PowerShell \u0026mdash; расширяемое средство автоматизации от Майкрософт с открытым исходным кодом, состоящее из оболочки с интерфейсом командной строки и сопутствующего языка сценариев. R \u0026mdash; язык программирования для статистической обработки данных и работы с графикой, а также свободная программная среда вычислений с открытым исходным кодом в рамках проекта GNU. Для старта рекомендую начать с цикла статей Ильи Шутова на Хабре  Сервисы  ukeeper.com \u0026mdash; Отправьте письмо на адрес drops@ukeeper.com со ссылкой на интересующую вас страницу, а вам в ответ придет письмо содержащее очищенную лишней мишуры и подготовленную статью. Использовал в комбинации с Onenote для создания коллекции статей по интересующим технологиям. Декодер \u0026mdash; Если у вас завалялся текст в неизвестной кодировке расшифровывает его. Daxformater \u0026mdash; Сервис обеспечивает красивое форматирование формул на языке DAX.  Вэбсайты  habr.ru \u0026mdash; Крупнейший и старейший в России профессиональный портал о ИТ. radio-t.com \u0026mdash; Старейший в рунете технический подкаст про ИТ devzen.ru \u0026mdash; Сильный технический подкаст про ИТ с упором качественную подачу сложных и современных технологий. piter-united.ru \u0026mdash; Крупнейший в Санкт-Петербурге форум и собрание специалистов ИТ отрасли и смежных специалистов. Собрание проходит каждый квартал. lektorium.tv \u0026mdash; Самый большой видеоархив академических лекций на русском языке. Коллекция постоянно пополняется ведущими учебными заведениями России. Доступ к материалам бесплатный. xgu.ru \u0026mdash; Набор профессиональных статей по открытым технологиям Linux с упором на телекоммуникации и виртуализацию. StackShare.io \u0026mdash; Сервис обзора современных платформ, стеков и программных средств.  Книги  Интерфейс. Основы проектирования взаимодействия  Расширения  Расширения для Visual Studio Code  ","date":1480204800,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1480204800,"objectID":"afbca800a5a8f6451a4e57de2fe90bef","permalink":"https://DmitriyVlasov.ru/ru/post/tools/","publishdate":"2016-11-27T00:00:00Z","relpermalink":"/ru/post/tools/","section":"post","summary":"В своей работы при поддержке информационных систем зачастую кроме предлагаемых основной платформой средств приходиться использовать еще ряд дополнительных инструментов и сервисов.\nНиже описан используемый мною \u0026ldquo;чемоданчик инструментов\u0026rdquo;.\nЧасть инструментов вы сами можете использовать уже сегодня и возможно использовали раньше. Часть инструментов может быть для вас новой. Все приведенные ниже инструменты использовались мною в работе на ежедневной основе (F#). По части инструментов были пилотные и экспериментальные проекты, но которые считаю очень перспективными и на которые, по моему мнению, стоит обратить внимание при развитии ИТ среды предприятия (язык R, язык PowerShell, Microsoft Power BI).","tags":[],"title":"Инструменты","type":"post"},{"authors":null,"categories":null,"content":"Ниже в таблице представлены расширения для Visual Studio Code используемые мною в работе на ежедневной основе. В столбце \u0026ldquo;Название расширения\u0026rdquo; приведены ссылки на официальную страницу расширения в магазине расширений Visual Studio.\n   Лого Название расширения Назначение Детали      code-settings-sync Синхронизирует настройки и расширения между разными компьютерами. Для использования Расширение необходима учетная запись на Гитхабе.    csharp Поддержка языка C# Официальная поддержка языка C# от Майкрософт. Осуществляется с помощью использования в бэкэнде проекта OmniSharp.    githistory      Ionide-FAKE      Ionide-fsharp      Ionide-Paket      MDTools      partial-diff      mssql Поддержка Майкрософт Сиквел Сервер. На момент публикации является предварительной публичной версией. Для быстрого старта смотри подробнее руководство по началу использования расширения (en).    path-intellisense Расширение значительно экономит, время когда нужно указать относительный путь к папке или файлу. Автоматически срабатывает в любом файле при работе со строкой в двойных или одинарных кавычках. Если содержимое строки начинается с точки или двойной точки пытается дополнить путь к файлу или папке. Двойная точка верх по каталогам. Одинарная вниз по каталогу.    PowerShell Поддержка языка Power Shell     spellcheck Проверка орфографии русского и английского языка. Поддержка осуществляется с помощью сервиса yandex spell.    vscode-icons Множество красивых иконок для файлов и папок. Набор иконок для огромного количества типов файлов и типовых папок часто встречающихся в проектах разработки на большинстве известных и не известных языков и проектов.    ","date":1480204800,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1480204800,"objectID":"d40a4b6d5305926a253d89ae9a7bcb16","permalink":"https://DmitriyVlasov.ru/ru/post/code-plugins/","publishdate":"2016-11-27T00:00:00Z","relpermalink":"/ru/post/code-plugins/","section":"post","summary":"Ниже в таблице представлены расширения для Visual Studio Code используемые мною в работе на ежедневной основе. В столбце \u0026ldquo;Название расширения\u0026rdquo; приведены ссылки на официальную страницу расширения в магазине расширений Visual Studio.\n   Лого Название расширения Назначение Детали      code-settings-sync Синхронизирует настройки и расширения между разными компьютерами. Для использования Расширение необходима учетная запись на Гитхабе.    csharp Поддержка языка C# Официальная поддержка языка C# от Майкрософт.","tags":[],"title":"Расширения для Visual Studio Code","type":"post"},{"authors":[],"categories":null,"content":"","date":1440532800,"expirydate":-62135596800,"kind":"page","lang":"ru","lastmod":1440532800,"objectID":"5a89bb8343d49cd7faae19cc53a27680","permalink":"https://DmitriyVlasov.ru/ru/talk/review-fsharp-4/","publishdate":"2015-08-25T22:00:00Z","relpermalink":"/ru/talk/review-fsharp-4/","section":"talk","summary":"История разработки четвертой версии F# в лицах. Улучшения языка F# и среды исполнения. Улучшения основой библиотеки языка FSharp.Core. Интегрированная среда разработки — новые функции Visual Studio 2015 и плагина \"Visual F# Power Tools\". Материалы и полезные сайты для старта изучения F#.","tags":[],"title":"Обзор F# 4.0","type":"talk"}]